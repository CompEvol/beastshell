<html>
<head>
<title>Table of Contents</title>
<link rel="stylesheet" type="text/css" href="../style.css">
</head>
<body bgcolor="ffffff"><h1>Introduction</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


This document is about BEASTShell. 
BEASTShell is a small, free, embeddable Java source interpreter with 
object scripting language features, written in Java.  BEASTShell executes 
standard Java statements and expressions but also extends Java into the 
scripting domain with common scripting language conventions and syntax.
BEASTShell is a <em>natural</em> scripting language for Java.
<p CLEAR="ALL"/>

<h2><a name="Scripting_vs._Application_Languages">Scripting vs. Application Languages</a></h2>

Traditionally, the primary difference between a scripting language and 
a compiled language has been in its type system: the way in which you define 
and use data elements.  You might be thinking that there is a more obvious 
difference here - that of "interpreted" code vs. compiled code.  But 
the compiler in and of itself does not fundamentally change the way you work 
with a language.  Nor does interpreting a language necessarily make 
it more useful for what we think of as "scripting".
It is the type system of a language that makes it possible for a compiler 
to analyze the structure of an application for correctness.
Without types, compilation is reduced to just a grammar check and an 
optimization for speed.
From the developer's perspective, it is also the type system that 
characterizes the way in which we interact with the code.
<p CLEAR="ALL"/>

Types are good.  Without strongly type languages it would be very hard to
write large scale systems and make any assertions about their correctness
before they are run.  But working with types imposes a burden on the developer.
Types are labels and labeling things can be tedious.  It can be especially 
tedious during certain kinds of development or special applications where 
it is flexibility and not program structure that is paramount.  
There are times where simplicity and ease of use is a more important 
criterion.  
<p CLEAR="ALL"/>

This is not just rationalization to cover some underlying laziness.  
Productivity affects
what people do and more importantly do *not* do in the real world, much more
than you might think.  There is a lot of important software that exists in 
the world today only because the cost/benefit ratio in some developer's mind 
reached a certain threshold.  
<p CLEAR="ALL"/>

Unit testing - one of the foundations of 
writing good code - is a prime example.  Unit tests for well written code are, 
in general, vitally important as a collective but almost insignificant 
individually.  It's a "tragedy of the commons" that leads individual
developers to repeatedly weigh the importance of writing another unit test
with working on "real code".
Give developers have a tool that makes it easy to perform a test with a line or
two of code they will probably use it.  If, moreover, it is also a tool that
they enjoy using during their development process - that saves the time, they
will be even more inclined to use it.   
<p CLEAR="ALL"/>

Customizability through scripting also opens the door to applications that 
are more powerful than the sum of their parts.  When users can extend, enhance,
and add to their applications they use them in new and unexpected ways.
<p CLEAR="ALL"/>

Scripting is powerful.
<p CLEAR="ALL"/>


<h2><a name="Tearing_Down_the_Barriers">Tearing Down the Barriers</a></h2>

Traditionally scripting languages have traded
in the power of types for simplicity.  Most scripting languages distill the 
type system to just one or a handful of types such as strings, numbers, or 
simple lists.  This is sufficient for many kinds of scripting.  
<p CLEAR="ALL"/>

Many scripting languages operate in a loose, unstructured land - a place 
dominated by text and course-grained tools.  
As such these scripting languages have evolved
sophisticated mechanisms for working with these simple types (regular
expressions, pipes, etc.). 
As a result there has developed a casm between the scripting languages 
and the application languages created by the collapse of the type system 
in-between.
The scripting languages have remained a separate species, isolated and 
speaking a different dialect from their brothers the application languages.  
<p CLEAR="ALL"/>

BEASTShell is a new kind of scripting language.  BEASTShell begins with 
the standard Java language and bridges it into the scripting domain in a 
natural way, but allowing the developer to relaxing types where appropriate.
It is possible to write BEASTShell scripts that look exactly like Java 
method code.  But it's also possible to write scripts that look more like
a traditional scripting language, while still maintaining the framework
of the Java syntax.
<p CLEAR="ALL"/>

BEASTShell emulates typed variables and parameters when they are used.  This 
allows you to "seed" your code with strong types where appropriate.  You can 
"shore up" repeatedly used methods as you work on them, migrating them 
closer to Java.  Eventually you may find that you want to compile
these methods and maintain them in standard Java.  With BEASTShell this is
easy.  BEASTShell does not impose a syntactic boundary between your 
scripts and Java.
<p CLEAR="ALL"/>

But the bridge to Java extends much deeper than simple code similarity.  
BEASTShell is one of a new breed of scripting languages made possible by
Java's advanced reflection capabilities.  Since BEASTShell can run in the same
Java virtual machine as your application, you can freely work with real,
live, Java objects - passing them into and out of your scripts.  Combined
with BEASTShell's ability to implement Java interfaces, you can achieve 
seamless and simple integration of scripting into your Java applications.
BEASTShell does not impose a type boundary between your scripts and Java.
<p CLEAR="ALL"/>

<!--
<h2><a name="History">History</a></h2>

What seems like an eternity ago, back in the summer of 1993, I was working at
Southwestern Bell Technology Resources and I was infatuated with the Tcl/Tk 
scripting language. 
On the advice of someone at Sun I also began playing around a bit with the 
Oak language written by James Gosling.
Little did I know that within just a few years Oak, which would become Java,
would not only spark a revolution, but that I would be writing one of the 
first books on the new Java language (Exploring Java, 
O'Reilly &amp; Associates) and creating 
Java's first scripting language, BEASTShell, drawing inspiration from Tcl.
<p CLEAR="ALL"/>

BEASTShell's first public release was not until 1997, but I had been
poking at it in one form or another for some time before that. BEASTShell 
as a language became practical when Sun added reflection to the Java language 
in version 1.1.  After that, and after having seen its value in helping me 
create examples and snippets for the second edition of my book, I decided to
try to polish it up and release it.
<p CLEAR="ALL"/>

BEASTShell has slowly, but steadily gained popularity since then.  It has
grown in fits and spurts as its contributor's time has allowed.  But recently
BEASTShell has achieved a sort of critical mass.  BEASTShell is distributed with
Emacs as part of the JDE and with Sun Microsystem's NetBeans / Forte for Java
IDEs.  BEASTShell is also bundled by BEA with their Weblogic application 
server.  We've had reports of BEASTShell being used everywhere from 
the high energy physics laboratory CERN, to classrooms teaching programming
to nine year olds.  BEASTShell is being used in everything from large 
financial applications all the way down to embedded systems floating in Buoys 
in the pacific ocean.   I attribute this success to the power of the open 
source development model and owe many thanks to everyone who has contributed.
<p CLEAR="ALL"/>
-->

<h2><a name="Conclusion">Conclusion</a></h2>

I believe that BEASTShell is the simplest and most natural scripting language 
for Java because it is, foremost, Java.  BEASTShell draws on a 
rich history of scripting languages for its scripting syntax and uses it to
very conservatively extend the Java language into this new domain.
I hope that you have half as much fun using BEASTShell as I have had working
on it and I welcome all comments and suggestions.
<p CLEAR="ALL"/>


<h1>Quick Start</h1>

Welcome to BEASTShell.
This is a crash course to get you going.  We'll leave out many
important options and details.  Please see the rest of the user's guide 
for more information.
<p CLEAR="ALL"/>

<table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
You can modify the classpath from within BEASTShell using the addClassPath()
and setClassPath() commands.
</td></tr></table></center><p/>

You can then run BEASTShell in either a GUI or command line mode:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
    java beast.app.shell.BEASTStudio       // run through BEASTStudio
or
    java bsh.Interpreter                   // run as text-only on the command line
or
    java bsh.Interpreter filename [ args ] // run script file
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

It's also possible to call BEASTShell from within your own Java applications,
to reach it in a remote server mode for debugging, to use it as a servlet.  
See "BEASTShell Modes of Operation" for more details.

<h2><a name="Java_Statements_and_Expressions">
Java Statements and Expressions
</a></h2>

BEASTShell understands standard Java statements, expressions, and 
method declarations.
Statements and expressions are all of the normal things that you'd say
inside a Java method such as variable declarations and assignments, 
method calls, loops, and conditionals.
<p CLEAR="ALL"/>

You can use these exactly as they would appear in Java,
however in BEASTShell you also have the option of working with "loosely typed"
variables.  That is, you can simply omit the types of variables that you use 
(both primitives and objects).  BEASTShell will only
signal an error if you attempt to misuse the actual type of the variable.
<p CLEAR="ALL"/>

Here are some examples:
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo = "Foo";    
four = (2 + 2)*2/2;
print( foo + " = " + four );  // print() is a BEASTShell command

// Do a loop
for (i=0; i&lt;5; i++)
    print(i);   

// Pop up a frame with a button in it
button = new JButton( "My Button" );
frame = new JFrame( "My Frame" );
frame.getContentPane().add( button, "Center" );
frame.pack();
frame.setVisible(true);
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

<h2><a name="BEASTObject">Creating BEASTObjects</a></h2>

One of the goals of BEASTShell is to make programming with BEASTObjects easier.
To create a BEASTObject in Java requires calling the constructor of the object, initialising 
each of its inputs then calling <tt>initAndValidate()</tt>. BEASTShell does these three
steps in one single statement, for example,

<table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import beast.evolution.alignment.*;
human = new Sequence(taxon="human", value="?"),
</pre></td></tr></table></center><p/>

is the BEASTShell equivalent of 

<table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import beast.evolution.alignment.*;

Sequence human = new Sequence();
human.taxonInput.setValue("human", human);
human.dataInput.setValue("?", human);
human.initAndValidate();
</pre></td></tr></table></center><p/>

Note that the name-value pairs in creating the BEASTObject -- these are independent
of the order. If you leave them out, the order of inputs is used (you can check by 
showing the BEAST documentation with <tt>?Sequence</tt>), which is more error prone
since it can change in the future.

Value do not necessarily need to be primitive values, you can use more complex objects
as well. For example, a two sequence alignment can be created using

<table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
human = new Sequence(taxon="human", value="?"),
chimp = new Sequence(taxon="chimp", value="?"),
data = new Alignment(sequence=human, sequence=chimp);
</pre></td></tr></table></center><p/>

<h2><a name="Help">Getting Help</a></h2>

The parser recognises lines starting with question marks as cries for help.
A single question mark followed by an expression brings up help on the
expression (in BEASTStudio this is shown in the help panel). A double question mark
followed by an object or class shows public fields and methods for that object or
class (again, in the help panel when running BEASTStudio).

<h2><a name="Useful_BEASTShell_Commands">
Useful BEASTShell Commands
</a></h2>

In the previous example we used a convenient "built-in" BEASTShell command 
called print(), to display values.  print() does pretty
much the same thing as System.out.println() except that it insures that the
output always goes to the command line.  print() also displays some types
of objects (such as arrays) more verbosely than Java would.  

Another related command is show(), which toggles on and off automatic 
display of the result of every line you type.
<p CLEAR="ALL"/>

Here are a few other examples of BEASTShell commands:

<ul>
<li> <strong>source(), run()</strong>  
- Read a bsh script into this interpreter, or run it
in a new interpreter</li>

<li> <strong>frame()</strong>  
- Display a GUI component in a Frame or JFrame.</li>

<li> <strong>load(),  save()</strong> 
- Load or save serializable objects to a file.</li>

<li> <strong>cd(), cat(), dir(), pwd(), etc.</strong>  
- Unix-like shell commands</li>

<li> <strong>exec()</strong> - Run a native application </li>

<li><strong>javap()</strong> - Print the methods and fields of an object,
similar to the output of the Java javap command.</li>

<li> <strong>setAccessibility()</strong> 
- Turn on unrestricted access to private and protected components.</li>

</ul>

<p CLEAR="ALL"/>
See the complete list of <a href="bshcommands.html">BEASTShell Commands</a>
for more information.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
BEASTShell commands are not really "built-in" but are simply BEASTShell scripts
that are automatically loaded from the classpath.  You can add your 
own scripts to the classpath to extend the basic command set.
</td></tr></table></center><p/>

<h2><a name="Scripted_Methods">
Scripted Methods
</a></h2>

You can declare and use methods in BEASTShell just as you would in a Java class.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
int addTwoNumbers( int a, int b ) {
    return a + b;
}

sum = addTwoNumbers( 5, 7 );  // 12
</pre></td></tr></table></center><p/>


Bsh methods may also allow dynamic (loose) argument and return types.  

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
add( a, b ) {
    return a + b;
}

foo = add(1, 2);            // 3
foo = add("Oh", " baby");   // "Oh baby"
</pre></td></tr></table></center><p/>

<h2><a name="Implementing_Interfaces">Implementing Interfaces</a></h2>

<em>Note: implementing arbitrary interfaces requires BEASTShell be run
under a Java 1.3 or higher environment.</em>
<p CLEAR="ALL"/>

You can use the standard Java anonymous inner class syntax to implement an
interface type with a script.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
ActionListener scriptedListener = new ActionListener() {
    actionPerformed( event ) { ... }
}
</pre></td></tr></table></center><p/>

You don't have to script all of the methods of an interface.  You can opt to
script only those that you intend to call if you want to.  
The calling code will simply throw an exception if it tries to 
invoke a method that isn't defined.
If you wish to override the behavior of a large number of methods - say to
produce a "dummy" adapter for logging - you can implement a special method
signature: invoke(name, args) in your scripted object. The invoke() method
is called to handle any undefined method invocations:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
ml = new MouseListener() {
    mousePressed( event ) { ... }
    // handle the rest
    invoke( name, args ) { print("Method: "+name+" invoked!");
}
</pre></td></tr></table></center><p/>

<h2><a name="Scripted_Objects">
Scripted Objects
</a></h2>

In BEASTShell, as in JavaScript and Perl, method "closures" allow you to create
scripted objects.  You can turn the results of a method call into an object
reference by having the method return the special value <strong>this</strong>.
You can then use the reference to refer to any variables set during the method 
call.  Useful objects need methods of course, so in BEASTShell scripted methods 
may also contain methods at any level.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {
    print("foo");
    x=5;

    bar() {
        print("bar");
    }

    return this;
}

myfoo = foo();    // prints "foo"
print( myfoo.x ); // prints "5"
myfoo.bar();      // prints "bar"
</pre></td></tr></table></center><p/>

If this "closure" thing seems strange to don't worry.  It's just an 
evolutionary step that languages acquired along the path to Objects.
Please see the user's manual for a more thorough explanation.
<p CLEAR="ALL"/>

Within your scripts, BEASTShell scripted objects 
(i.e. any <em>'this'</em> type reference like myFoo in the previous example) 
can automatically implement any Java interface type.  When Java code calls 
methods on the interface the corresponding scripted methods will be invoked to 
handle them.  BEASTShell will automatically "cast" your scripted object 
when you attempt to pass it as an argument to a method that takes an interface
type.
For passing script references outside of BEASTShell, you can perform an 
explicit cast where necessary.  Please see the user manual for full details.
<p CLEAR="ALL"/>

<h2><a name="Calling_BEASTShell_From_Your_Application">Calling BEASTShell From Your Application</a></h2>

You can evaluate text and run scripts from within your application by
creating an instance of the BEASTShell interpreter and using the eval()
or source() commands.  You may pass in variable references to objects you 
wish to use in scripts via the set() method and retrieve results with the 
get() method.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import bsh.Interpreter;

Interpreter i = new Interpreter();  // Construct an interpreter
i.set("foo", 5);                    // Set variables
i.set("date", new Date() ); 

Date date = (Date)i.get("date");    // retrieve a variable

// Eval a statement and get the result
i.eval("bar = foo*10");             
System.out.println( i.get("bar") );

// Source an external script file
i.source("somefile.bsh");
</pre></td></tr></table></center><p/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>In the above example the Interpreter's eval() method also returned the 
value of bar as the result of the evaluation.</td></tr></table></center><p/>

<h2><a name="Conclusion">Conclusion</a></h2>

We hope this brief introduction gets you started.  Please see the full user
manual for more details.  Please consult the mailing list archives for
more useful information.  http://www.beanshell.org/

<h1>Basic Syntax</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


BEASTShell is, foremost, a Java interpreter. So you probably already know 
most of what you need to start scripting with BEASTShell.  This 
section describes specifically what portion of the Java language BEASTShell 
interprets and how BEASTShell extends it or "loosens" it to be more 
scripting-language-like.
<p CLEAR="ALL"/>

<h2><a name="Standard_Java_Syntax"> Standard Java Syntax </a></h2>

In a BEASTShell script (and on the command line) you can type normal 
Java statements and expressions and display the results.  
Statements and expressions are the kinds of things you normally find 
inside of a Java method: variable assignments, method calls, math 
expressions, for-loops, etc.  

<p CLEAR="ALL"/>

Here are some examples:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
/*
    Standard Java syntax
*/

// Use a hashtable
Hashtable hashtable = new Hashtable();
Date date = new Date();
hashtable.put( "today", date );

// Print the current clock value
print( System.currentTimeMillis() );

// Loop
for (int i=0; i&lt;5; i++)
    print(i);

// Pop up a frame with a button in it
JButton button = new JButton( "My Button" );
JFrame frame = new JFrame( "My Frame" );
frame.getContentPane().add( button, "Center" );
frame.pack();
frame.setVisible(true);
</pre></td></tr></table></center><p/>

You can also define your own methods and use them just as you would inside a 
Java class.  We'll get to that in a moment.

<h2><a name="Loosely_Typed_Java_Syntax">Loosely Typed Java Syntax </a></h2>

In the examples above, all of our variables have declared types. e.g. 
"JButton button".  Beanshell will enforce these types, as you will see if 
you later try to assign something other than a JButton to the variable 
"button" (you will get an error message).
However BEASTShell also supports "loose" or dynamically typed variables.
That is, you can refer to 
variables without declaring them first and without specifying any type.
In this case BEASTShell will do type checking where appropriate at runtime.  
So, for example, we could have left off the types in the above example and 
written all of the above as:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
/*
    Loosely Typed Java syntax
*/

// Use a hashtable
hashtable = new Hashtable();
date = new Date();
hashtable.put( "today", date );

// Print the current clock value
print( System.currentTimeMillis() );

// Loop
for (i=0; i&lt;5; i++)
    print(i);

// Pop up a frame with a button in it
button = new JButton( "My Button" );
frame = new JFrame( "My Frame" );
frame.getContentPane().add( button, "Center" );
frame.pack();
frame.setVisible(true);
</pre></td></tr></table></center><p/>

This may not seem like it has saved us a great deal of work.  But you will
see the difference when you come to rely on scripting as part of your
development and testing process; especially for in interactive use.
<p CLEAR="ALL"/>

When a "loose" variable is used you are free to reassign it to another type of 
Java object later.  Untyped BEASTShell variables can also freely hold Java 
primitive values like <b>int</b>
and <b>boolean</b>.  Don't worry, BEASTShell always knows the real types and 
only lets you use the values where appropriate.  For primitive types this 
includes doing the
correct numeric promotion that the real Java language would do when you use
them in an expression.
<p CLEAR="ALL"/>

<h2><a name="Exception_Handling">Exception Handling</a></h2>

Exception handling using try/catch blocks works just as it does in Java.  
For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
try {
    int i = 1/0;
} catch ( ArithmeticException e ) {
    print( e );
}
</pre></td></tr></table></center><p/>

But you can loosely type your catch blocks if you wish:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
try {
    ...
} catch ( e ) { 
    print( "caught exception: "+e );
}
</pre></td></tr></table></center><p/>

<h2><a name="Basic_Scoping_of_Variables">Basic Scoping of Variables</a></h2>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
The default scoping of loosely typed variables was
changed to be more consistent with Java.  BEASTShell still supports an alternate
scoping used in earlier versions.  This mode can be enabled for legacy code by 
setting the system property "localscoping" to true.  
See appendix "Local Scoping".
</td></tr></table></center><p/>

Variable scoping in BEASTShell behaves, wherever possible, just like that in 
Java.  Ordinary Java, however, does not offer "loose" variables 
(variables that can be used without being declared first).  
So we must define their behavior within BEASTShell.
We'll see in the next section that untyped variables - variables that are not 
declared and not assigned a value elsewhere - default to the 
<em>local</em> scope.  
This means that, in general, if you assign a value to a variable without first
declaring it, you are creating a new local variable in the current scope.
<p CLEAR="ALL"/>

<h3>Blocks</h3>

Blocks are statements between curly braces {}.  In BEASTShell, as in Java, 
blocks define a level of scope for typed variables: typed variables declared
within a block are local to the block.  Other assignments within the block 
occur, as always, wherever the variable was defined.
<p CLEAR="ALL"/>

Untyped variables in BEASTShell, however, are not constrained by blocks.
Instead they act as if they were declared at the outer (enclosing)
scope's level.  
With this in mind, BEASTShell code looks just like Java code.

In BEASTShell if you declare a typed variable within a block it is local to the
block.  But if you use an untyped variable (which looks just like an ordinary
assignment in Java) it behaves as an assignment to the enclosing scope.
<p CLEAR="ALL"/>

This will make sense with a few examples:
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// Arbitrary code block
{
    y = 2;      // Untyped variable assigned
    int x = 1;  // Typed variable assigned
}
print( y ); // 2
print( x ); // Error! x is undefined.

// Same with any block statement: if, while, try/catch, etc.
if ( true ) {
    y = 2;      // Untyped variable assigned
    int x = 1;  // Typed variable assigned
}
print( y ); // 2
print( x ); // Error! x is undefined.
</pre></td></tr></table></center><p/>

Variables declared in the for-init area of a for-loop follow the same
rules as part of the block:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
for( int i=0; i&lt;10; i++ ) {  // typed for-init variable
    j=42;
}
print( i ); // Error! 'i' is undefined.
print( j ); // 42

for( z=0; z&lt;10; z++ ) { }   // untyped for-init variable
print( z ); // 10
</pre></td></tr></table></center><p/>

<h2><a name="Variable_Modifiers">Variable Modifiers</a></h2>

The standard Java variable modifiers may be used on typed variables:
private / protected / public, final, transient, volatile, static.
Only 'final' is currently implemented.  The others are currently ignored.
<p CLEAR="ALL"/>
Modifiers may not be applied to untyped variables.

<h2><a name="Convenience_Syntax">Convenience Syntax</a></h2>

In BEASTShell you may access JavaBean properties as if they were fields:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
button = new java.awt.Button();
button.label = "my button";  // Equivalent to: b.setLabel("my button");
print( button.label );       // Equivalent to print( b.getLabel() );
</pre></td></tr></table></center><p/>

JavaBean properties are simply pairs of "setter" and "getter" methods that
adhere to a naming convention.  In the above example BEASTShell located
a "setter" method with the name "setLabel()" and used it to assign the string
value.  It then found the method named getLabel() to retrieve the value.
<p CLEAR="ALL"/>

Boolean properties may optionally use the syntax "is" for their "getter".
e.g.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
Float f = new Float(42f);
print( f.infinite );  // Equivalent to print( f.isInfinite() ); // false
</pre></td></tr></table></center><p/>

If there is any ambiguity with an actual Java field name of the object 
(e.g. label in the above example) then the actual field name takes precedence.

If you wish to avoid any ambiguity BEASTShell provides an additional, 
uniform syntax for accessing both Java Bean properties and Hashtable or Map 
entries.  You may use the "{}" curly brace construct with a 
String identifier as a qualifier on any variable of the appropriate type:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
b = new java.awt.Button();
b{"label"} = "my button";  // Equivalent to: b.setLabel("my button");

h = new Hashtable();
h{"foo"} = "bar";          // Equivalent to: h.put("foo", "bar");
</pre></td></tr></table></center><p/>

Where the java.util.Collections API is available, Maps are also supported.
<p CLEAR="ALL"/>

<h3>Enhanced 'for' Loop</h3>

BEASTShell supports the Java 1.5 style enhanced for-loop for iterating over
collections and array types.  (Note that you do not have to be running Java 1.5
to use this feature).

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
List foo = getSomeList();

for ( untypedElement : foo ) 
	print( untypedElement ); 

for ( Object typedElement: foo ) 
	print( typedElement );

int [] array = new int [] { 1, 2, 3 };

for( i : array ) 
	print(i);

for( char c : "a string" )
	print( c ); 
</pre></td></tr></table></center><p/>

Supported iterable types include all the obvious things.  

<ul>
<li>JDK 1.1+ - (no collections): Enumeration, arrays, Vector, String, StringBuffer</li>
<li>JDK 1.2+ - (w/collections): Collections, Iterator</li>
</ul>

See also the BshIterator API which supports the ehanced for-loop and allows
iteration over these types using the dynamically loaded BEASTShell Collection 
manager.
<p CLEAR="ALL"/>

<h3>Switch Statements</h3>

In BEASTShell, the switch statement may be used not only with numeric types
but with objects.  For example, you may switch on Dates and Strings which
are compared for equality with their equals() methods:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
dateobj = new Date();

switch( dateobj ) 
{
	case newYears:
		break;
	case christmas:
		break;
	default:
}
</pre></td></tr></table></center><p/>


<h2><a name="Auto_Boxing_and_Unboxing">Auto Boxing and Unboxing</a></h2>

"Boxing" and "Unboxing" are the terms used to describe automatically wrapping 
a primitive type in a wrapper class and unwrapping it as necessary.  Boxing
is a feature of Java (SDK1.5) and has been supported in BEASTShell for many
years.
<p CLEAR="ALL"/>

BEASTShell supports boxing and unboxing of primitive types.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
int i=5;
Integer iw = new Integer(5);
print( i * iw );  // 25

Vector v = new Vector();
v.put(1); 
int x = v.getFirstElement();
</pre></td></tr></table></center><p/>

<h2><a name="Importing_Classes_and_Packages">Importing Classes and Packages</a></h2>

In BEASTShell as in Java, you can either refer to classes by their fully
qualified names, or you can <strong>import</strong> one or more classes 
from a Java package.
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// Standard Java
import javax.xml.parsers.*;
import mypackage.MyClass;
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

In BEASTShell import statements may appear anywhere, even inside a method, 
not just at the top of a file.  In the event of a conflict, later imports take
precedence over earlier ones.
<p CLEAR="ALL"/>

A somewhat experimental feature is the "super import".  With it you may 
automatically import the entire classpath, like so:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import *;
</pre></td></tr></table></center><p/>

The first time you do this BEASTShell will map out your entire classpath;
so this is primarily intended for interactive use.  Note that importing every
class in your classpath can be time consuming.  It can also result in a lot 
of ambiguities.  Currently BEASTShell will report an error when resolving an 
an ambiguous import from mapping the entire classpath.  You may disambiguate 
it by importing the class you intend.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
The BEASTShell which() command will use the classpath mapping capability to
tell you where exactly in your classpath a specified class is located:
<pre>
bsh % which( java.lang.String );
Jar: file:/usr/java/j2sdk1.4.0/jre/lib/rt.jar
</pre>
</td></tr></table></center><p/>

See "Class Path Management" for information about modifying the BEASTShell
classpath at run-time with the addClassPath() or setClassPath() commands.
<p CLEAR="ALL"/>
Also see "BEASTShell Commands" for information about importing new BEASTShell
commands from the classpath.
<p CLEAR="ALL"/>

<h3>Default Imports</h3>

By default, common Java core and extension packages are imported for 
you.  They are, in the order in which they are imported:

<ul>
<li>javax.swing.event</li>
<li>javax.swing</li>
<li>java.awt.event</li>
<li>java.awt</li>
<li>java.net</li>
<li>java.util</li>
<li>java.io</li>
<li>java.lang</li>
</ul>
<p CLEAR="ALL"/>

Two BEASTShell package classes are also imported by default:
<p CLEAR="ALL"/>

<ul>
<li>bsh.EvalError</li>
<li>bsh.Interpreter</li>
</ul>
<p CLEAR="ALL"/>

Finally, we should mention that BEASTShell commands may be imported from the 
classpath. The BEASTShell commands are imported in the following way:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
importCommands("/bsh/commands");
importCommands("/beast/commands");
</pre></td></tr></table></center><p/>

Any commands added to these directories will automatically be available to BEASTShell scripts,
but other paths can be added as well. We will discuss how to import your own commands in 
a later section.

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
The classes java.awt.List and java.util.List are both imported by default.  
Because java.util.List is imported later, as part of the java.util package,
it takes precedence.  To access java.awt.List simply import it in, or the
java.awt package again your script.  Later imports take precedence.
</td></tr></table></center><p/>

<h2><a name="Document_Friendly_Entities">Document Friendly Entities</a></h2>

BEASTShell supports special overloaded text forms of all common operators
to make it easier to embed BEASTShell scripts inside other kinds of documents
(e.g XML).
<p CLEAR="ALL"/>

<table border="1" cellpadding="5">
<tr><td><strong>@gt</strong></td><td>&gt;</td></tr>
<tr><td><strong>@lt</strong></td><td>&lt;</td></tr>
<tr><td><strong>@lteq</strong></td><td>&lt;=</td></tr>
<tr><td><strong>@gteq</strong></td><td>&gt;=</td></tr>
<tr><td><strong>@or</strong></td><td>||</td></tr>
<tr><td><strong>@and</strong></td><td>&amp;&amp;</td></tr>
<tr><td><strong>@bitwise_and</strong></td><td>&amp;</td></tr>
<tr><td><strong>@bitwise_or</strong></td><td>|</td></tr>
<tr><td><strong>@left_shift</strong></td><td>&lt;&lt;</td></tr>
<tr><td><strong>@right_shift</strong></td><td>&gt;&gt;</td></tr>
<tr><td><strong>@right_unsigned_shift</strong></td><td>&gt;&gt;&gt;</td></tr>
<tr><td><strong>@and_assign</strong></td><td>&amp;=</td></tr>
<tr><td><strong>@or_assign</strong></td><td>|=</td></tr>
<tr><td><strong>@left_shift_assign</strong></td><td>&lt;&lt;=</td></tr>
<tr><td><strong>@right_shift_assign</strong></td><td>&gt;&gt;=</td></tr>
<tr><td><strong>@right_unsigned_shift_assign</strong></td><td>&gt;&gt;&gt;=</td></tr>
</table>

<h1>Scripted Methods</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


You can define define methods in BEASTShell, just as they would appear in Java:
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
int addTwoNumbers( int a, int b ) {
    return a + b;
}
</pre></td></tr></table></center><p/>

And you can use them in your scripts just as you would any Java method or
"built-in" BEASTShell command:
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
sum = addTwoNumbers( 5, 7 );
</pre></td></tr></table></center><p/>

Just as BEASTShell variables may be dynamically typed, methods may have 
dynamic argument and return types.  We could, for example, have declared
our add() method above like so:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
add( a, b ) {
    return a + b;
}
</pre></td></tr></table></center><p/>

In this case, BEASTShell would dynamically determine the types when the method is
called and attempt to "do the right thing":

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo = add(1, 2);
print( foo ); // 3

foo = add("Oh", " baby");
print( foo ); // Oh baby
</pre></td></tr></table></center><p/>

In the first case Java performed arithmetic addition on the integers 1 and 2.
(By the way, if we had passed in numbers of other types BEASTShell would have 
performed the appropriate numeric promotion and returned the correct Java 
primitive type.)  
In the second
case BEASTShell performed the usual string concatenation for String types and
returned a String object.  This example is a bit extreme, as there are no
other overloaded operators like string concatenation in Java.  But it serves 
to emphasize that BEASTShell methods can work with loose types.
<p CLEAR="ALL"/>

Methods with unspecified return types may return any type of object (as in
the previous example).
Alternatively they may also simply issue a "return;" without a value, in
which case the effective type of the method is "void" (no type).  In 
either case, the return statement is optional.  If the method does not 
perform an explicit "return" statement and the return type is not explicitly
set to void, the value of the last statement or expression in the method body 
becomes the return value (and must adhere to any declared return typing).
<p CLEAR="ALL"/>

<h3>Method Modifiers and 'throws' Clauses</h3>

The standard Java modifiers may be applied to methods:
private / protected / public, synchronized, final, native, abstract, and 
static.  
<p CLEAR="ALL"/>

The synchronized modifier is the only modifier currently implemented.  The
others are ignored.  The 'throws' clause of methods is checked for valid 
class type names, but is not otherwise enforced.
<p CLEAR="ALL"/>

Synchronized methods are synchronized on the object representing the method's 
common parent scope, so they behave like Java methods contained in a class.
We will return to this topic after discussing scripted objects and "closures".

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// foo() and bar() are synchronized as if they were in a common class
synchronized foo() { }
synchronized bar() { }
</pre></td></tr></table></center><p/>

<h2><a name="Scoping_of_Variables_and_Methods">Scoping of Variables and Methods</a></h2>

As in Java, a method can refer to the values of variables and method names 
from the enclosing scope (in Java the "enclosing scope" would be a class).  
For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
a = 1;
anotherMethod() { ... }

foo() {
    print( a );
	a = a+1;
	anotherMethod();
}

// invoke foo()
foo();      // prints 1
print( a ); // prints 2
</pre></td></tr></table></center><p/>

Variables and methods are "inherited" from the parent scope in the usual way.
In the example above there are just two levels of scope: the top or "global"
scope and the scope of the method foo().  Later we'll talk about scripting
objects in BEASTShell and see that there can be arbitrary levels of scoping
involved.  But the rules will be the same.
<p CLEAR="ALL"/>

As in Java, a typed variable is not visible outside the scope in which it is 
declared.  So declaring a variable with a type is a way to limit its scope or
make a <em>local</em> variable.  In BEASTShell using an untyped or 
"loosely" typed variable is also equivalent to declaring a local
variable.  That is, if you use a variable that has not been defined elsewhere,
it defaults to the local scope:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
a = 1;

foo() {
	a = a + 1; // a is defined in parent scope
	b = 3;     // undefined, defaults local scope
	int c = 4; // declared local scope
}

// invoke foo()
print( a ); // prints 2
print( b ); // ERROR! b undefined
print( c ); // ERROR! c undefined
</pre></td></tr></table></center><p/>

In the above example the variable 'a' is declared in the global
scope.  When its value is read and assigned inside of foo() the global value 
of 'a' will be affected.  
<p CLEAR="ALL"/>

The variable 'b' is a usage of an untyped variable.  Since 'b' has not been
declared or assigned a value in any enclosing scope, it becomes a local
variable 'b' in the scope of foo.  The variable 'c' is explicitly declared
(with a type) in the scope of foo() and is therefore, of course, local to 
foo().
<p CLEAR="ALL"/>

Later we'll see that BEASTShell allows arbitrary nesting of methods.  If we were
to declare another method inside of foo() it could see all of these
variables (a, b, and c) as it is also in the scope of foo().
<p CLEAR="ALL"/>

<h3>Scoping of Loosely Typed Variables</h3>

As in Java, declaring a variable with a type will always make it local.  
Even if the variable exists in the outer scope, it will be hidden by the 
local variable declaration.  But what of loosely typed variables?  As we've
seen, untyped variable usage looks just like an ordinary Java assignment.  What
do we do if we want to make a local variable with the same name as a global
one?  One answer would be to resort to declaring the variable with a type.  
But if we wish to continue working with loosely typed variables in this case we
have two options:  We can explicitly declare a loosely typed variable with the
BEASTShell 'var' type.  Or we can simply qualify our assignment with the 'this.'
qualifier.
<p CLEAR="ALL"/>

If you wish to, you can explicitly declare an untyped variable
(making it local) using the special type 'var'. e.g.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {
	var a = 1;
}
foo();
print( a ); // ERROR! a is undefined!
</pre></td></tr></table></center><p/>

'var' is a magic type in BEASTShell that represents a loose (untyped) variable.
The default value of a variable declared with 'var' is null.
<p CLEAR="ALL"/>

Alternately, you can use the scope modifier 'this' to explicitly qualify the
variable assignment and make it local. 

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {
	this.a = 1;
}
foo();
print( a ); // ERROR! a is undefined!
</pre></td></tr></table></center><p/>

In this example we used the modifier 'this' to qualify an untyped
variable's scope and make it local.  We will explain 'this' and what it means 
in BEASTShell scripted methods in the next section on Scripted Objects.  
<p CLEAR="ALL"/>


<h2><a name="Scope_Modifier:_'super'">Scope Modifier: 'super'</a></h2>
<p CLEAR="ALL"/>

Within a method, it is possible to explicitly qualify a variable or 
method reference with the identifier 'super' in order to refer 
to a variable or method defined in an enclosing scope (the scope in which the 
method is defined or "higher"). e.g.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
int a = 42;

foo() {
    int a = 97;
    print( a );
    print( super.a );
}

foo();  // prints 97, 42
</pre></td></tr></table></center><p/>

As in Java, the 'super' modifiers tells the scoping to begin its search for the
variable or method in the parent scope. 
In the case above, the variable 'a' by default refers to the variable in the
local scope.  By qualifying 'a' with 'super' we can refer to the variable 'a'
in the global scope (the "topmost" scope).
<p CLEAR="ALL"/>

So, we've seen that 'super' can be used to refer to the method's parent 
context.  We'll see in the next section how 'this' and 'super' are used
in scripting Objects in BEASTShell.
<p CLEAR="ALL"/>

<h1>Scripted Objects</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


Many people who use BEASTShell use it to write scripts that 
work with existing Java classes and APIs, or perform other kinds of dynamic 
activities for their own applications at run-time without the aid of a 
compiler.  Often this means writing relatively unstructured code -
for example, a sequence of method invocations or loops, all contained in a 
single script file or eval() statement. 
In the previous section we saw that BEASTShell is also capable of scripting 
methods, just like Java.  Creating methods and new BEASTShell commands 
(which are just methods in their own files) is the 
natural progression of organizing your scripts into re-usable and 
maintainable components.
<p CLEAR="ALL"/>

Beyond methods and structured programming lie, of course, objects and the 
full breadth of object oriented programming.  In Java objects are the products
of classes.  While BEASTShell is compatible with standard Java syntax for 
statements, expressions, and methods, you can't yet script new Java classes 
within BEASTShell.
Instead, BEASTShell allows you to script objects as "method closures", 
similar to the way it is done in Perl 5.x, JavaScript, and other object-capable 
scripting languages.  This style of scripting objects (which we'll describe 
momentarily) is simple and flows very naturally from the style of scripting 
methods.  The syntax, as you'll see, is a straightforward extension of the 
standard Java concept of referring to an object with a 'this' reference.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
In standard Java, a method inside of an object (an instance method) may refer
to the enclosing object using the special variable 'this'.  For example:
<pre>
    // MyClass.java
    MyClass {
        Object getObject() {
            return this; // return a reference to our object
        }
    }
</pre>

In the example above, the getObject() method of MyClass returns a reference
to its own object instance (an instance of the MyClass object) using 'this'.
</td></tr></table></center><p/>

<h2><a name="The_'this'_reference">The 'this' reference</a></h2>

As in most languages, an executing method in BEASTShell has its own 
"local" scope 
that holds argument (parameter) variables and locally declared variables.  For
example, in the following code segment any variables that we might use within 
the foo() method will normally only be visible within the scope of foo() and 
for the lifetime of one particular foo() method invocation:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// Define the foo() method:
foo() {
    int bar = 42;
    print( bar );
}   

// Invoke the foo() method:
foo();  // prints 42

print( bar ); // Error, bar is undefined here 
</pre></td></tr></table></center><p/>

In the above, the bar variable is local to foo() and therefore not available
outside of the method invocation - it is thrown away when the method exits,
just like a standard Java local variable.
<p CLEAR="ALL"/>

Now comes the twist - In BEASTShell you have the option to "hang on" to the 
scope of a method invocation after exiting the method by referring to the 
special 'this' reference.  As in Java, 'this' refers to the current object 
context.   The only difference is that in this case the context is associated
with the method and not a class instance.
<p CLEAR="ALL"/>

By saving the 'this' reference after the method returns, you can continue to 
refer to variables defined within the method, using the standard Java "." 
notation:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {
    int bar = 42;
    return this;
}

fooObject = foo();
print( fooObject.bar ); // prints 42!
</pre></td></tr></table></center><p/>

In the above, the value returned by the foo() method (the 'this' reference)
can be thought of as an instance of a "foo" object.  Each foo() method 
invocation effectively creates a new object; foo() is now not just a method,
but a kind of object constructor.
<p CLEAR="ALL"/>

In the above case our foo object is not so much an object, but really more of a 
structure.  It contains variables (bar) but no "behavior".  The next twist
that we'll introduce is that BEASTShell methods are also allowed to contain 
other methods:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {
    bar() {
        ...
    }
}
</pre></td></tr></table></center><p/>
Scripted methods may define any number of nested methods in this way, to an 
arbitrary depth.  The methods are "local" to the method invocation.  
<p CLEAR="ALL"/>

Statements and expressions within the enclosing BEASTShell method can call 
their "local" methods just like any other method.  (Locally declared methods 
override outer-more methods like local variables hide instance variables in
Java.)  The enclosed methods are not directly visible outside of their
enclosing method.  However, as you might expect, we can invoke them as we
would on a Java object, through an appropriate object reference:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {
    int a = 42;
    bar() {
        print("The bar is open!");
    }
    
    bar();
    return this;
}

// Construct the foo object
fooObject = foo();     // prints "the bar is open!"
// Print a variable of the foo object
print ( fooObject.a );  // 42
// Invoke a method on the foo object
fooObject.bar();       // prints "the bar is open!"
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

Methods declared inside block structures within methods behave just as if they
were declared directly in the method.  i.e. there are no block-local methods.
For example:
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {

	bar() { }

	if ( true ) {
		bar2() { }
	}

	return this;
}
</pre></td></tr></table></center><p/>

In the above example the methods bar() and bar2() are both defined within
foo().
<p CLEAR="ALL"/>

<p CLEAR="ALL"/>
In the next section we'll return to the topic of variable scoping and
go into more depth about how to work with scripted methods and objects.
<p CLEAR="ALL"/>

<h1>Scope Modifiers</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


Now that we've seen how methods can be nested and treated as objects, we
can revisit the topic of variable scope and scope modifiers.
<p CLEAR="ALL"/>

<h2><a name="'this',_'super',_and_'global'">'this', 'super', and 'global'</a></h2>

In the "Scripted Methods" section we described the use of 'super' to refer to a 
method's parent scope (the scope in which the method is defined).  
And in the previous section we talked 
about super's brother 'this', which refers to the current method's scope,
allowing us to think of a method scope as an object.  Now we can see how 
these concepts are related.  Any method scope, and indeed the 'global' scope,
can be thought as an object context. A scripted object can be thought of as
encapsulated in a parent scope that determines its "environment" - its inherited
variables and methods.  
<p CLEAR="ALL"/>

The references 'this', 'super', and 'global' are really the same
kind of reference - references to BEASTShell method contexts, which can 
be used as scripted objects.  From here on We'll refer to 'this', 
'super', 'global', and any other reference to a scripted object context in
general as a <em>'this' type reference</em>.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
If you print a 'this' type reference you'll see what it refers to:

<pre>
    bsh % print( this );
    'this' reference (XThis) to Bsh object: global
    bsh % foo() { print(this); print(super); }
    bsh % foo();
    'this' reference (XThis) to Bsh object: foo
    'this' reference (XThis) to Bsh object: global
</pre>
</td></tr></table></center><p/>
<p CLEAR="ALL"/>

The above note shows that the foo() method's 'this' reference is local
(named 'foo') and that it's parent is the global scope; the same scope in
which foo is defined.

<h3>'global'</h3>

The scope modifier 'global' allows you to always refer to the top-most
scope.  In the previous note you can see that the top level script context
is called "global" and that it appears again as the 'super' of our foo() 
method.  The global context is always the top scope of the script.  
It is the global namespace of the current interpreter.  Referring
to 'super' from the top scope simply returns the same 'global' again.  

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
  global.foo = 42; 
</pre></td></tr></table></center><p/>

Global variables are not special in any way.  Their visibility derives simply
from the fact that they are in the topmost scope.  However, for those who do
not like the idea of qualifying anything with "global".  You can always use a
more object oriented approach like the following.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// Create a top level object to hold some state
dataholder = object();

foo() {
    ...
    bar() {
        dataholder.value = 42;
    }

    bar();
    print( dataholder.value );
}
    
</pre></td></tr></table></center><p/>

In the above example we used a global object to hold some state, rather than
putting the 'value' variable directly in the global scope. 

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
In the above example we used the BEASTShell object() command to create an
"empty" BEASTShell scripted object context in which to hold some data.  The
object() command is just a standard empty method named object() that 
returns 'this'.  The variable 'dataholder' above is a 'this' type reference and
has all of the properties of any other BEASTShell object scope.
</td></tr></table></center><p/>

<h2><a name="Synchronized_Methods_Revisited">Synchronized Methods Revisited</a></h2>

Now that we have covered the meaning of 'this' and 'super' with respect to
BEASTShell methods we can define the meaning of the 'synchronized' modifier
for BEASTShell methods.  Synchronized BEASTShell methods behave as if they were
in a common class by synchronizing on their common 'super' reference object.
For example, in the four cases in the following example, synchronization occurs
on the same Java object.  That object is the 'this' type reference of the 
global scope (a Beanshell object of type bsh.This):

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
print( this ); // 'this' reference (XThis) to Bsh object: global

// The following cases all synchronize on the same lock
synchronized ( this ) { }     // synchronized block
synchronized int foo () { }   // synchronized method foo()
synchronized int bar () { }   // synchronized method bar()
int gee() {
	synchronized( super ) { }  // synchronized blockinside gee() 
}
</pre></td></tr></table></center><p/>

<h1>Scripting Interfaces</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


One of the most powerful features of BEASTShell is the ability to script 
Java interfaces.  This feature allows you to write scripts that serve
as event handlers, listeners, and components of other Java APIs.  It also 
makes calling scripted components from within your applications easier
because they can be made to look just like any other Java object.
<p CLEAR="ALL"/>

<h2><a name="Anonymous_Inner-Class_Style">Anonymous Inner-Class Style</a></h2>

One way to get a scripted component to implement a Java interface is by 
using the standard Java anonymous inner class syntax to construct a scripted 
object implementing the interface type.  For example:
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
buttonHandler = new ActionListener() {
    actionPerformed( event ) { 
        print(event);
    }
};

button = new JButton();
button.addActionListener( buttonHandler );
frame(button);
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

In the above example we have created an object that implements the 
<code>ActionListener</code> interface and assigned it to a variable called 
buttonHandler.
The buttonHandler object contains the scripted method actionPerformed(),
which will be called to handle invocations of that method on the interface.
<p CLEAR="ALL"/>

Note that in the example we registered our scripted ActionListener with a 
JButton using its addActionListener() method.  The JButton is, of course, 
a standard Swing component written in Java.  It has no knowledge that when it 
invokes the buttonHandler's actionPerformed() method it will actually be 
causing the BEASTShell interpreter to run a script to evaluate the outcome.
<p CLEAR="ALL"/>

To generalize beyond this example a bit - Scripted interfaces work by looking
for scripted methods to implement the methods of the interface.
A Java method invocation on a script that implements an interface causes 
BEASTShell to look for a corresponding scripted method with 
a matching signature (name and argument types).  BEASTShell then invokes the 
method, passing along the arguments and passing back any return value.
When BEASTShell runs in the same Java VM as the rest of the code, you can
freely pass "live" Java objects as arguments and return values, working
with them dynamically in your scripts; the integration can be seamless.
<p CLEAR="ALL"/>

<!--See also <a href="examples/dragtext.html">the dragText example</a>.
<p CLEAR="ALL"/>-->

<h2><a name="'this'_references_as_Interface_Types">'this' references as Interface Types</a></h2>

The anonymous inner class style syntax which we just discussed allows you
to explicitly create an object of a specified interface type, just as you
would in Java.  But BEASTShell is more flexible than that.  In fact, 
within your BEASTShell scripts, any 'this' type script reference can
automatically implement any interface type, as needed.  This means that you can 
simply use a 'this' reference to your script or a scripted object anywhere
that you would use the interface type.  BEASTShell will automatically "cast" 
it to the correct type and perform the method delegation for you. 
<p CLEAR="ALL"/>

For example, we could script an event handler for our button even
more simply using just a global method, like this:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
actionPerformed( event ) {
    print( event );
}

button = new JButton("Foo!");
button.addActionListener( this );
frame( button ); 
</pre></td></tr></table></center><p/>

Here, instead of making a scripted object to hold our actionPerformed()
method we have simply placed the method in the current context 
(the global scope) and told BEASTShell to look there for the method.
<p CLEAR="ALL"/>

Just as before, when <code>ActionEvents</code> are fired by the button, your 
actionPerformed() method will be invoked.  The BEASTShell 'this' reference 
to our script implements the interface and directs method invocations to the 
appropriately named method, if it exists.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
If you want to have some fun, try entering the previous example interactively 
in a shell or on the command line.  You'll see that you can then redefine 
actionPerformed() as often as you like by simply entering the method again.  
Each button press will find the current version in your shell.  In a sense,
you are working inside a dynamic Java object that you are creating and 
modifying as you type.  <!--Neat, huh?  Be the Bean!-->
</td></tr></table></center><p/>

Of course, you don't have to define all of your interface methods globally.
You can create references in any scope, as we discussed in "Scripting Objects".
For example, the following code creates a scripted message button object which
displays a message when its pushed.  The scripted object holds its own
actionPerformed() method, along with a variable to hold the Frame used for 
the GUI:
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
messageButton( message ) {
    JButton button = new JButton("Press Me");
    button.addActionListener( this );
    JFrame frame = frame( button );
 
    actionPerformed( e ) {
        print( message );
        frame.setVisible(false);
    }
}

messageButton("Hey you!");
messageButton("Another message...");
</pre></td></tr></table></center><p/>

The above example creates two buttons, with separate messages.  Each button
prints its message when pushed and then dismisses itself.  
The buttons are created by separate calls to the messageButton() method,
so each will have its own method context, separate local variables, and a 
separate instance of the ActionListener interface handler.  Each registers 
itself (its own method context) as the ActionListener for its button, using 
its own 'this' reference.
<p CLEAR="ALL"/>

In this example all of the "action" is contained in messageButton() method
context.  It serves as a scripted object that implements the interface and
also holds some state, the frame variable, which is used to dismiss the GUI.
More generally however, as we saw in the "Scripting Objects" section,
we could have returned the 'this' reference to the caller, allowing it to 
work with our messageButton object in other ways.
<p CLEAR="ALL"/>

<h2><a name="Interface_Types_and_Casting">Interface Types and Casting</a></h2>

It is legal, but not usually necessary to perform an explicit cast of a 
BEASTShell scripted object to an interface type.   For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
actionPerformed( event ) {
    print( event );
}

button.addActionListener( 
    (ActionListener)this ); // added cast
</pre></td></tr></table></center><p/>

In the above, the cast to ActionListener would have been done automatically
by BEASTShell when it tried to match the 'this' type argument to the signature
of the addActionListener() method.
<p CLEAR="ALL"/>

Doing the cast explicitly has the same effect, but takes a different route
internally.  With the cast, BEASTShell creates the necessary adapter 
that implements the ActionListener interface first, at the time of the cast,
and then later finds that the method is a perfect match.  
<p CLEAR="ALL"/>

What's the difference?  Well, there are times where performing
an explicit cast to control when the type is created may be important. 
Specifically, when you are passing references out of your script, to Java 
classes that don't immediately use them as their intended type.

In our earlier discussion we said that automatic casting happens "within
your BEASTShell scripts".  And in our examples so far BEASTShell has always
had the opportunity to arrange for the scripted object to become the correct
type, before passing it on.  But it is possible for you to pass a 'this'
reference to a method that, for example, takes the type 'Object', in which
case BEASTShell would have no way of knowning what it was destined for later.
You might do this, for example, if you were placing your scripted objects
into a collection (Map or List) of some kind.  In that case, you can 
control the process by performing an explicit cast to the desired type before 
the reference leaves your script.
<p CLEAR="ALL"/>

Another case where you may have to perform a cast is where you are using
BEASTShell in an embedded application and returning a scripted object as
the result of an eval() or a get() variable from the Interpreter class.  
There again
is a case where BEASTShell has no way of knowing the intended type within
the script.   By performing an explicit cast you can create the type
before the reference leaves your script.
<p CLEAR="ALL"/>
We'll discuss embedded applications of BEASTShell in the
"Embedding BEASTShell" section a bit later, along with the Interpreter 
getInterface() method, which is another way of accomplishing this type of
cast from outside a script.
<p CLEAR="ALL"/>

<h2><a name="&quot;Dummy&quot;_Adapters_and_Incomplete_Interfaces">"Dummy" Adapters and Incomplete Interfaces</a></h2>

It is common in Java to see "dummy" adapters created for interfaces that
have more than one method.  The job of a dummy adapter is to implement all
of the methods of the interface with stubs (empty bodies), allowing the
developer to extend the adapter and override just the methods of interest.
<p CLEAR="ALL"/>

We hinted in our earlier discussion that BEASTShell could handle scripted
interfaces that implement only the subset of methods that are actually used 
and that is indeed the case.  You are free in BEASTShell to script only the 
interface methods that you expect to be called.  The penalty for leaving out 
a method that is actually invoked is a special run-time exception: 
java.lang.reflect.UndeclaredThrowableException, which the caller will 
receive.  
<p CLEAR="ALL"/>

The UndeclaredThrowableException is an artifact of Java Proxy API that makes
dynamic interfaces possible.  It says that an interface threw a checked
exception type that was not prescribed by the method signature.  This is 
a situation that cannot normally happen in compiled Java.  So the Java 
reflection API handles it by wrapping the checked exception in this special
unchecked (RuntimeException) type in order to throw it.  
You can get the underlying
error using the exception's getCause() method, which will, in this case, 
reveal the BEASTShell EvalError exception, reporting that the scripted method 
of the correct signature was not found.
<p CLEAR="ALL"/>


<h3>The invoke() Meta-Method</h3>

BEASTShell provides a very simple short-hand mechanism for scripting interfaces
with large numbers of methods.  You can implement the special method 
<em>invoke( name, args )</em> in any scripted 
context.  The invoke() method will be called to handle the invocation of
any method of the interface that is not defined. For example:
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
mouseHandler = new MouseListener() {
    mousePressed( event ) { 
        print("mouse button pressed");  
    }

    invoke( method, args ) { 
        print("Undefined method of MouseListener interface invoked:"
            + name +", with args: "+args
        );
    }
};
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

In the above example we have neglected to implement four of the five 
methods of the MouseListener interface.  They will be handled by the invoke()
method, which will simply print the name of the method and its arguments.
However since mousePressed() is defined it will be called for the interface.
<p CLEAR="ALL"/>

Here is a slightly more realistic example of where this comes in handy.
Let's use the invoke() method to print the names of methods called via
the ContentHandler interface of the Java SAX API, while parsing an XML 
document.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import javax.xml.parsers.*;
import org.xml.sax.InputSource;

factory = SAXParserFactory.newInstance();
saxParser = factory.newSAXParser();
parser = saxParser.getXMLReader();
parser.setContentHandler( this );

invoke( name, args ) {
    print( name );
}

parser.parse( new InputSource(bsh.args[0]) );
</pre></td></tr></table></center><p/>

By running this script with the XML file as an argument, we can see which
of the dozen or so methods of the SAX API are being exercised by the structure 
of the document, without having to write a stub for each of them.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
You can use the invoke( name, args ) meta-method directly in your own scope or
in the global scope as well, in which case you can handle arbitrary "unknown"
method invocations yourself, perhaps to implement your own "virtual" commands.
Try typing this on the command line:
<pre>
  invoke(name,args) { print("Command: "+name+" invoked!"); }
  noSuchMethod(); // prints "Command: noSuchMethod() invoked!"
</pre>
</td></tr></table></center><p/>

<h2><a name="Threads_-_Scripting_Runnable">Threads - Scripting Runnable</a></h2>

BEASTShell 'this' type references can implement the standard java.lang.Runnable 
interface.  So you can declare a "run()" method in your bsh objects and make 
it the target of a Thread:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {
    run() {
        // do work...
    }
    return this;
}

foo = foo();
// Start two threads on foo.run()
new Thread( foo ).start();
new Thread( foo ).start();
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

BEASTShell is thread-safe internally, so as long as your scripts do not 
explicitly do anything ordinarily non-thread safe (e.g. access shared 
variables or objects) you can write multi-threaded scripts.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
You can use the bg() "background" command to run an external script in a 
separate thread.  See bg().
</td></tr></table></center><p/>
<p CLEAR="ALL"/>

<!--<h2><a name="Limitations">Limitations</a></h2>
<p CLEAR="ALL"/>

When running under JDK 1.3 or greater BEASTShell can script any kind of 
Java interface.  However when running under JDK 1.2 (or JDK1.1 + Swing) only 
the core AWT and Swing interfaces are available.  To support those legacy
cases a special extension of the 'this' reference implementation (the 
bsh.This class) is loaded which implements these interfaces along with 
Runnable, statically.  
<p CLEAR="ALL"/>-->

<h1>Special Variables and Values</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


In addition to the scope modifiers: 'this', 'super', 'global', BEASTShell
supports a number of pre-defined system variables, "magic" values, and methods.
<p CLEAR="ALL"/>

<em>Special Values</em>
<p CLEAR="ALL"/>
<ul>
<li><strong>$_</strong> - The value of the last expression evaluated.  The
strange construct for this is drawn from Perl, but the idea exists in many
scripting languages.  It is useful for getting back 
the last result when you are working interactively.  
</li>

<li><strong>$_e</strong> - The last uncaught exception object thrown.  
This is useful in interactive use for retrieving the last exception to inspect
it for details.
</li>

<li><strong>bsh</strong> - The BEASTShell root system object, containing 
system information and variables.</li>

<li><strong>bsh.args</strong> - An array of Strings passed as command 
line arguments to the BEASTShell interpreter.</li>

<li><strong>bsh.shared</strong> - A special static space which is 
shared across all interpreter instances.  Normally each bsh.Interpreter 
instance is entirely independent; having its own unique global namespace
and settings.  bsh.shared is implemented as a static namespace in the 
bsh.Interpreter class.  It was added primarily to support communication
among instances for the GUI desktop.
</li>

<li><strong>bsh.console</strong> - If BEASTShell is running in 
its GUI desktop mode, this variable holds a reference to the current 
interpreter's console, if it has one.</li>

<li><strong>bsh.appletcontext</strong> - If BEASTShell
is running inside an Applet, the current applet context, if one exists.</li>

<li><strong>bsh.cwd</strong> - A String representing the current working
directory of the BEASTShell interpreter.  This is used or manipulated by the 
cd(), dir(), pwd(), and pathToFile() commands.</li>

<li><strong>bsh.show</strong> - A boolean value used by the show() command.
It indicates whether results are always printed, for interactive use.
</li>

<li><strong>bsh.interactive</strong> - A boolean indicating whether this 
interpreter running in an interactive mode</li> 

<li><strong>bsh.evalOnly</strong> - A boolean indicating whether this 
interpreter has an input stream or whether is it only serving as an engine 
for eval() operations (e.g. for embedded use).</li>
</ul>
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
The choice of "bsh" for the root system object name was somewhat unfortunate
because it conflicts with the current package name for BeanShell (also bsh).
This means that if you wish to work with BeanShell classes explicitly from
BEASTShell scripts (e.g. bsh.Interpreter) you must first import them, e.g.:
<pre>
    import bsh.Interpreter;
    i=new Interpreter();
</pre>
</td></tr></table></center><p/>

<h2><a name="Special_Members_of_'this'_type_References">Special Members of 'this' type References</a></h2>
<p CLEAR="ALL"/>

'this' type references have several "magic" members:  

<ul>

<li><strong>this.variables</strong> - An array of Strings listing the 
variables defined in the current method context (namespace).</li>

<li><strong>this.methods</strong> - An array of Strings listing the methods 
defined the current method context (namespace).</li>

<li><strong>this.interpreter</strong> - A bsh.Interpreter reference to the 
currently executing BEASTShell Interpreter object.</li>

<li><strong>this.namespace</strong> - A bsh.NameSpace reference to the BEASTShell
NameSpace object of the current method context. See "Advanced Topics".</li>

<li><strong>this.caller</strong> - A bsh.This reference to the calling
BEASTShell method context. See "Variables and Scope Modifiers".</li>

<li><strong>this.callstack</strong> - An array of bsh.NameSpace references 
representing the "call stack" up to the current method context. 
See "Advanced Topics".</li>

</ul>
<p CLEAR="ALL"/>

These magic references are primarily used by BEASTShell commands. 
<p CLEAR="ALL"/>

<h2><a name="Undefined_Variables">Undefined Variables</a></h2>
<p CLEAR="ALL"/>
You can test to see if a variable is defined using the special value 
<b>void</b>.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
if ( foobar == void )
    // undefined
</pre></td></tr></table></center><p/>

You can return a variable to the undefined state using the unset() command:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
a == void;  // true
a=5;
unset("a"); // note the quotes
a == void;  // true
</pre></td></tr></table></center><p/>

<h2><a name="Setting_the_Command_Prompt">Setting the Command Prompt</a></h2>

Users may set the command line prompt string for use in interactive mode 
by setting the value of the variable bsh.prompt or by defining the scripted
method (or command) getBshPrompt().  
<p CLEAR="ALL"/>

If the command or method getBshPrompt() is defined it will be called to
get a string to display as the user prompt.  For example, one could
define the following method to place the current working directory into
their command prompt:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
	getBshPrompt() { return bsh.cwd + " % "; }
</pre></td></tr></table></center><p/>

The default getBshPrompt() command returns the value of the variable
bsh.prompt if it is defined or the string "bsh % " if not.  If the
getBshPrompt() method or command does not exist, throws an exception, or does
not return a String, a default prompt of "bsh % " will be used.
<p CLEAR="ALL"/>

<h1>Adding BEASTShell Commands</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


BEASTShell Commands are scripted methods or compiled Java classes which are 
dynamically loaded from the classpath to implement a method.
All of the standard commands we discuss in this manual live in the BEASTShell
JAR file under the path /bsh/commands.
<p CLEAR="ALL"/>

Adding to the set of "prefab" commands supplied with BEASTShell is as easy as 
writing any other BEASTShell methods.  You simply have to place your 
script into a file named with the same name as the command and place the
file in the classpath.  You may then "import" the commands with the
importCommands() method.  
<p CLEAR="ALL"/>

Command files can be placed anywhere in the BEASTShell classpath.
You can even use the addClassPath() or setClassPath() commands to add new 
command directories or JARs containing commands to your script at any time.
<p CLEAR="ALL"/>

<h2><a name="Hello_World">Hello World</a></h2>

For example, let's make a helloWorld() command:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// File: helloWorld.bsh
helloWorld() { 
    print("Hello World!");
}
</pre></td></tr></table></center><p/>

Place the command file helloWorld.bsh in a directory or JAR in your
classpath and import it with the importCommands() command.  
You can either set the classpath
externally for Java or inside of BEASTShell with the addClassPath() command.
For example, suppose we have placed
the file in the path: /home/pat/mycommands/helloWorld.bsh.
We could then do:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
addClassPath("/home/pat");  // If it's not already in our classpath
importCommands("/mycommands");
</pre></td></tr></table></center><p/>

We can now use helloWorld() just like any other BEASTShell command.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
helloWorld(); // prints "Hello World!"
</pre></td></tr></table></center><p/>

importCommands() will accept either a "resource path" style path name or a
Java package name.  Either one is simply converted to a resource path or 
Java package name as required to load scripts or compiled BEASTShell command
classes.  A relative path (e.g. "mycommands") is turned into an absolute path
by prepending "/".  You may import "loose" commands (like unpackaged classes)
at the top of the classpath by importing "/".
<p CLEAR="ALL"/>
If for example you have placed BEASTShell commands along with your other 
classes in a Java package called com.xyz.utils in your classpath, you can 
import those commands with:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// equivalent
importCommands("com.xyz.utils");
importCommands("/com/xyz/utils");
</pre></td></tr></table></center><p/>

Imported commands are scoped just like imported classes.  So if you import
commands in a method or object they are local to that scope.

<h3>Overloaded Commands</h3>

BEASTShell command scripts can contain any number of overloaded forms of the
command method, e.g.:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// File: helloWorld.bsh
helloWorld() { 
	print("Hello World!"); 
}
helloWorld( String msg ) { 
	print("Hello World: "+msg); 
}
</pre></td></tr></table></center><p/>

BEASTShell will select the appropriate method based on the
usual rules for methods selection.


<h2><a name="Compiled_Commands">Compiled Commands</a></h2>

You can also implement BEASTShell commands as compiled classes instead of
scripts if you wish.  Your class name must simply be the name of the command
(matching case as well) and it must implement one or more static invoke()
methods who's signatures match a pattern.  The first two
arguments of the invoke() method must be the bsh.Interpreter
and bsh.CallStack objects that provide context to all BEASTShell scripts.
Then any number (possibly zero) of arguments, which are the arguments of the
command may follow.  
BEASTShell will select the appropriate method based on the
usual rules for methods selection.
<p CLEAR="ALL"/>

The dir() command is an example of a BEASTShell command that is implemented in
Java.   Let's look at a snippet from it to see how it implements a pair of
invoke() methods for the dir() and dir(path) commands.
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
/**
	Implement dir() command.
*/
public static void invoke( Interpreter env, CallStack callstack ) 
{
	String dir = ".";
	invoke( env, callstack, dir );
}

/**
	Implement dir( String directory ) command.
*/
public static void invoke( 
	Interpreter env, CallStack callstack, String dir ) 
{
...
}
</pre></td></tr></table></center><p/>

<h2><a name="User_Defined_Commands_with_invoke()">User Defined Commands with invoke()</a></h2>

It is useful to note that the invoke() meta-method which we described in the
section "Scripting Interfaces" can be used directly in scope as well as through
an object reference and one could use this to load arbitrary commands or
implement arbitrary behavior for commands (undefined method calls).  For
example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
invoke( String methodName, Object [] arguments ) { 
	print("You invoked the method: "+ methodName );
}

// invoke() will be called to handle noSuchMethod()
noSuchMethod("foo"); 
</pre></td></tr></table></center><p/>

invoke() is called to handle any method invocations for undefined methods 
within its scope.  In this case we have declared it at the global scope.
<p CLEAR="ALL"/>

<h2><a name="Commands_Scope">Commands Scope</a></h2>

Scripted BEASTShell commands are loaded when no existing method matches
the command name.
When a command script is loaded it is sourced (evaluated) in the 'global' scope
of the interpreter.  This means that once the command is loaded the methods
declared in the command script are then defined in the interpreter's global
scope and subsequent calls to the command are simply handled by
the those methods as any other scripted method.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
Note that this means that currently scripted commands
may only be loaded once and then they are effectively cached. 
</td></tr></table></center><p/>
<p CLEAR="ALL"/>

<h2><a name="Getting_the_Caller_Context">Getting the Caller Context</a></h2>

A useful feature of BEASTShell for command writers is the 'this.caller'
reference, which allows you to create side effects (set or modify variables) in
the method caller's scope.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
fooSetter() {
    this.caller.foo=42;
}
</pre></td></tr></table></center><p/>

The above command has the effect that after running it the variable 'foo'
will be set in the caller's scope. e.g.:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
fooSetter();
print( foo ); // 42
</pre></td></tr></table></center><p/>

It may appear that we could simply have used the 'super' modifier to accomplish
this and in this case it would have worked.  However it would not have been 
correct in general because the 'super' of fooSetter() always points to the same
location - the scope in which it was defined.   We would like fooSetter() to
set the variable in whatever scope it was called from.
<p CLEAR="ALL"/>

To reiterate:
The 'super' of a method is always
the context in which the method was defined.  But the caller may be any context
in which the method is used.  In the following example,
the parent context of foo() and the caller context of foo() are the same:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() { ... }
foo();
</pre></td></tr></table></center><p/>

But this is not always the case, as for bar() in the following example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() { 
    bar() { ... }
    ...
}

// somewhere
fooObject.bar();
</pre></td></tr></table></center><p/>

The special "magic" field reference: 'this.caller' makes it possible 
to reach the context of whomever called bar().  The 'this.caller' reference 
always refers to the calling context of the current method context.
<p CLEAR="ALL"/>

<img src="../images/caller.gif"/>
<p CLEAR="ALL"/>

The diagram above shows the foo() and bar() scopes, along with the caller's
scope access via 'this.caller'.
<p CLEAR="ALL"/>

This is very useful in writing BEASTShell commands.  
BEASTShell command methods are always loaded into the global 
scope.  If you refer to 'super' from your command you will simply 
get 'global'.  Often it is desirable to write commands that explicitly have 
side effects in the caller's scope.  The ability to do so makes it possible to
write new kinds of commands that have the appearance of being "built-in" 
to the language.  
<p CLEAR="ALL"/>

A good example of this is the eval() BEASTShell command.  eval() evaluates
a string as if it were typed in the current context.  To do this, it sends
the string to an instance of the BEASTShell interpreter.  But when it does
so it tells the interpreter to evaluate the string in a specific namespace:
the namespace of the caller; using this.caller.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
    eval("a=5");
    print( a ); // 5
</pre></td></tr></table></center><p/>

The eval() command is implemented simply as:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
eval( String text ) {
	this.interpreter.eval( text, this.caller.namespace );
}
</pre></td></tr></table></center><p/>

As a novelty, you can follow the call chain further back if you want to 
by chaining the '.caller' reference, like so:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
    this.caller.caller...;
</pre></td></tr></table></center><p/>

Or, more generally, another magic reference 'this.callstack' returns an
array of bsh.NameSpace objects representing the full call "stack".  This is
an advanced topic for developers that we'll discuss in another location.

<h2><a name="setNameSpace()">setNameSpace()</a></h2>

In the previous discussion we used the this.caller reference to allow us to
write commands that have side effects in the caller's context.  This is a
powerful tool.  But what happens when one command calls another command that
intends to do this?  That would leave the side effects in the first command's
context, not it's original caller.  Fortunately this doesn't come up all that
often.  But there is a general way to solve this problem.
That is to use the powerful 
setNameSpace() method to "step into" the caller's context.  After that we may
set variables and call methods exactly as if we were in the caller's context
(because we are).  If all commands did this there would be no need to use the
this.caller reference explicitly (indeed, we may make it idiomatic for all 
commands to do this in the future).  
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
myCommand() {
	// "Step into" the caller's namespace.
	setNameSpace( this.caller.namespace );

	// work as if we were in the caller's namespace.
}
</pre></td></tr></table></center><p/>

You can try out the setNameSpace() command with arbitrary object scope's 
as well.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
object = object();

// save our namespace
savedNameSpace = this.namespace;

// step into object's namespace
setNameSpace( object.namespace );

// Work in the object's scope
a=1;
b=2;

// step back 
setNameSpace( savedNameSpace );

print( object.a ); // 1
print( object.b ); // 2

print( a ); // ERROR! undefined
</pre></td></tr></table></center><p/>


<h2><a name="Getting_the_Invocation_Text">Getting the Invocation Text</a></h2>

You can get specific information about the invocation of a method
using namespace.getInvocationLine() and namespace.getInvocationText().
The most important use for this is in support of the ability to write an
assert() method for unit tests that automatically prints the assertion text.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
assert( boolean condition ) 
{
    if ( condition )
        print( "Test Passed..." );
    else {
        print(
            "Test FAILED: "
            +"Line: "+ this.namespace.getInvocationLine()
            +" : "+this.namespace.getInvocationText()
            +" : while evaluating file: "+getSourceFileInfo()
        );
        super.test_failed = true;
    }
}
</pre></td></tr></table></center><p/>

<h2><a name="Working_with_Dirctories_and_Paths">Working with Dirctories and Paths</a></h2>

BEASTShell supports the notion of a <em>current working directory</em> for
commands that work with files.  The cd() command can be used to change the
working directory and pwd() can be used to display the current value.
The BEASTShell current working directory is stored in the variable bsh.cwd.
<p CLEAR="ALL"/>

All commands that work with files respect the working directory, including
the following:
<p CLEAR="ALL"/>

<ul>
<li>dir()</li>
<li>source()</li>
<li>run(),</li>
<li>cat()</li>
<li>load()</li>
<li>save()</li>
<li>mv()</li>
<li>rm()</li>
<li>addClassPath()</li>
</ul>

<h3>pathToFile()</h3>

As a convenience for writing your own scripts and commands you can use
the pathToFile() command to translate a relative file path to an absolute
one relative to the current working directory.  Absolute paths are unmodified.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
absfilename = pathToFile( filename );
</pre></td></tr></table></center><p/>

<h3>Path Names and Slashes</h3>

When working with path names you can generally just use forward slashes
in BEASTShell.  Java localizes forward slashes to the appropriate value
under Windows environments.  If you must use backslashes remember to 
escape them by doubling them:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
dir("c:/Windows"); // ok
dir("c:\\Windows"); // ok
</pre></td></tr></table></center><p/>


<h2><a name="Working_With_Class_Identifiers">Working With Class Identifiers</a></h2>

You may have noticed that certain BEASTShell commands such as javap(),
which(), and browseClass() which take a class as an argument can accept any 
type of argument, including a plain Java class identifier.  For example,
all of the following are legal:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
javap( Date.class ); // use a class type directly
javap( new Date() ); // uses class of object
javap( "java.util.Date" ); // Uses string name of class
javap( java.util.Date );  // Use plain class identifier
</pre></td></tr></table></center><p/>

In the last case above we used the plain Java class identifier 
java.util.Date.  In Beanshell this resolves to a bsh.ClassIdentifier
reference.  You can get the class represented by a ClassIdentifier using the 
Name.identifierToClass() method.  Here is an example of how to work
with all of the above, converting the argument to a class type:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
	import bsh.ClassIdentifier;

    if ( o instanceof ClassIdentifier )
        clas = this.namespace.identifierToClass(o);
    if ( o instanceof String)
        clas = this.namespace.getClass((String)o);
    else if ( o instanceof Class )
        clas = o;
    else
        clas = o.getClass();
</pre></td></tr></table></center><p/>


<h2><a name="Working_with_Iterable_Types">Working with Iterable Types</a></h2>

The bsh.BshIterator interface provides the standard hasNext() and next()
methods of the java.util.Iterator interface, but is available in all versions
of Java and can be created for all composite types including arrays.  
<p CLEAR="ALL"/>

The BEASTShell CollectionManager is used to get a BshIterator for an interable
object or array.  It is a dynamically loaded extension, so it provides support
for the java.util.Collections API when available, but does not break 
compatability for Java 1.1 applications.

You can use this in the implementation of BEASTShell commands to iterate 
over Enumeration, arrays, Vector, String, StringBuffer and 
(when the java.util.collections API is present) Collections and Iterator.
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
cm = CollectionManager.getCollectionManager();
if ( cm.isBshIterable( myObject ) ) 
{
	BshIterator iterator = cm.getBshIterator( myObject );
	while ( iterator.hasNext() )
		i = iterator.next();
}
</pre></td></tr></table></center><p/>

<h1>Class Loading and Class Path Management</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


BEASTShell is capable of some very fine grained and sophisticated class 
reloading and modifications to the class path.  BEASTShell can even map
the entire class path to allow for automatic importing of classes.


<h2><a name="Changing_the_Class_Path">Changing the Class Path</a></h2>

<strong>addClassPath( URL | path )</strong>
<p CLEAR="ALL"/>
Add the specified directory or archive to the classpath.  Archives may be
located by URL, allowing them to be loaded over the network.
<p CLEAR="ALL"/>
Examples:
<p CLEAR="ALL"/>
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
addClassPath( "/home/pat/java/classes" );
addClassPath( "/home/pat/java/mystuff.jar" );
addClassPath( new URL("http://myserver/~pat/somebeans.jar") );
</pre></td></tr></table></center><p/>

Note that if you add class path that overlaps with the existing Java user 
classpath then the new path will effectively reload the classes in that
area.
<p CLEAR="ALL"/>

If you add a relative path to the classpath it is evaluated to an absolute
path; it does not "move with you".

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
cd("/tmp");
addClassPath("."); // /tmp
</pre></td></tr></table></center><p/>

<strong>setClassPath( URL [] )</strong>
<p CLEAR="ALL"/>
Change the entire classpath to the specified array of directories and/or 
archives.  
<p CLEAR="ALL"/>

This command has some important side effects.  It effectively causes all
classes to be reloaded (including any in the Java user class path at startup).
Please see "Class Reloading" below for further details.
<p CLEAR="ALL"/>

Note: setClassPath() cannot currently be used to make the classpath smaller 
than the Java user path at startup.
<p CLEAR="ALL"/>


<h2><a name="Auto-Importing_from_the_Classpath">Auto-Importing from the Classpath</a></h2>

As an alternative to explicitly importing class names you may use the
following statement to trigger automatic importing:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import *;
</pre></td></tr></table></center><p/>

There may be a significant delay while the class path is mapped.  This is why
auto-importing is not turned on by default.  When run interactively, Bsh will 
report the areas that it is mapping.
<p CLEAR="ALL"/>

It is only necessary to issue the auto-import command once.  Thereafter changes
in the classpath via the addClassPath() and setClassPath() commands will
remap as necessary.
<p CLEAR="ALL"/>

<em>
Note: As of BEASTShell 1.1alpha new class files added to the classpath 
(from outside of BEASTShell) after mapping will not be seen in imports.
</em>


<h2><a name="Reloading_Classes">Reloading Classes</a></h2>

BEASTShell provides an easy to use mechanism for reloading classes from the 
classpath.  It is possible in BEASTShell to reload arbitrary subsets of classes 
down to a single class file.  However There are subtle issues to be understood 
with respect to what it means to reload a class in the Java environment. 
Please see the discussion of class loading detail below.  But in a nutshell,
it is important that classes which work together be reloaded together at
the same time, unless you know what you are doing.
<p CLEAR="ALL"/>

<strong>reloadClasses( [ package name ] )</strong>
<p CLEAR="ALL"/>
The most course level of class reloading is accomplished by issuing the 
reloadClasses() command with no arguments.  

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
reloadClasses();
</pre></td></tr></table></center><p/>

This will effectively reload all
classes in the current classpath (including any changes you have made through
addClassPath()).
<p CLEAR="ALL"/>

<em>
Note: that reloading the full path is actually a light weight operation that 
simply replaces the class loader - normal style class loading is done as
classes are subsequently referenced.
</em>
<p CLEAR="ALL"/>

Be aware that any object instances which you have previously created may not 
function with new objects created by the new class loader.  Please see the
discussion of class loading details below.
<p CLEAR="ALL"/>

You can also reload all of the classes in a specified package:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
reloadClasses("mypackage.*");
</pre></td></tr></table></center><p/>

This will reload only the classes in the specified package.  The classes will
be reloaded even if they are located in different places in the classpath (e.g.
if you have some of the package in one directory and some in another).
<p CLEAR="ALL"/>

As a special case for reloading unpackaged classes the following commands
are equivalent:
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
reloadClasses(".*") 
reloadClasses("&lt;unpackaged&gt;")
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

You can also reload just an individual class file:
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
reloadClasses("mypackage.MyClass") 
</pre></td></tr></table></center><p/>

<em>Note: As of alpha1.1 classes contained in archives (jar files) cannot be
reloaded. i.e. jar files cannot be swapped.</em>
<p CLEAR="ALL"/>

<h4>Mapping the path</h4>

Unlike the reloadClases() command which reloads the entire class path,
when you issue a command to reload a package or individual class name
BEASTShell must map some portions of the classpath to find the location of 
those class files.  This operation can be time consuming, but it is only
done once.  If running in interactive mode feedback will be given on the
progress of the mapping.
<p CLEAR="ALL"/>

<h2><a name="Loading_Classes_Explicitly">Loading Classes Explicitly</a></h2>

In order to perform an explicit class lookup by name while taking into 
account any BEASTShell class path modification you must use a replacement
for the standard Class.forName() method.
<p CLEAR="ALL"/>

The getClass() command will load a class by name, using the BEASTShell
classpath.  Alternately, you can consult the class manager explicitly:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
name="foo.bar.MyClass";
c = getClass( name );
c = BshClassManager.classForName( name );  // equivalent
</pre></td></tr></table></center><p/>

<h2><a name="Setting_the_Default_ClassLoader">Setting the Default ClassLoader</a></h2>

The bsh.Interpeter setClassLoader() and bsh.BshClassManager.setClassLoader()
methods can be used to set an external class loader which is consulted
for all basic class loading in BEASTShell.  
<p CLEAR="ALL"/>

BEASTShell will use the specified class loader at the same point where it 
would otherwise use the plain Class.forName().  If no explicit classpath 
management is done from the script (addClassPath(), setClassPath(), 
reloadClasses()) then BEASTShell will only use the supplied classloader.  
If additional classpath management is done then BEASTShell will perform that 
in addition to the supplied external classloader.  However BEASTShell is not 
currently able to reload classes supplied through the external classloader.  
<p CLEAR="ALL"/>


<h2><a name="Class_Loading_in_Java">Class Loading in Java</a></h2>

A fundamental Java security proposition is that classes may only be loaded 
through a class loader once and that classes loaded through different class
loaders live in different name spaces.  By different name spaces I mean that
they are not considered to be of the same type, even if they came from the
very same class file.
<p CLEAR="ALL"/>
You can think of this in the following way:  When you load classes through
a new class loader imagine that every class name is prefixed with the 
identifier "FromClassLoaderXXX" and that all internal references to other
classes loaded through that class loader are similarly rewritten.  Now if
you attempt to pass a reference to a class instance loaded through another
class loader to one of your newly loaded objects, it will not recognize it
as the same type of class.
<p CLEAR="ALL"/>

BEASTShell works with objects dynamically through the reflection API, so
your scripts will not have a problem recognizing reloaded class objects.
However any objects which have you already created might not like them.


<h2><a name="Class_Loading_in_BEASTShell">Class Loading in BEASTShell</a></h2>

The following is a discussion of the BEASTShell class loader architecture,
which allows both course class path extension and fine grained individual
class reloading.
<p CLEAR="ALL"/>

<strong>Thriftiness</strong> - Abiding by the BEASTShell thriftiness 
proposition: no class loading code is exercised unless directed by a
command.  BEASTShell begins with no class loader and only adds class loading
in layers as necessary to achieve desired effects.
<p CLEAR="ALL"/>

The following diagram illustrates the two layer class loading scheme:
<p CLEAR="ALL"/>
<center>
<img src="../images/bshclassloading.gif"/>
</center>
<p CLEAR="ALL"/>

A "base" class loader is used to handle course changes to the classpath 
including added path.  Unless directed by setClassPath() the base loader will
only add path and will not cover existing Java user class path.  This prevents
unnecessary class space changes for the existing classes.
<p CLEAR="ALL"/>

Packages of classes and individual classes are mapped in sets by class 
loaders capable of handling discrete files.  A mapping of reloaded classes
is maintained.  The discrete file class loaders will also use this mapping
to resolve names outside there space, so when any individual class is reloaded
it will see all previously reloaded classes as well.
<p CLEAR="ALL"/>

The BshClassManager knows about all class loader changes and broadcasts
notification of changes to registered listeners.  BEASTShell namespaces use
this mechanism to dereference cached type information, however they do not
remove existing object instances.
<p CLEAR="ALL"/>

Type caching is extremely important to BEASTShell performance.  So changing
the classloader, which necessitates clearing all type caches, should be 
considered an expensive operation. 
<p CLEAR="ALL"/>


<h1>Modes of Operation</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


There are currently five basic modes of operation for running BEASTShell:

<ul>
<li>Standalone scripts</li>
<li>Embedded in your application</li>
<li>Remote server mode</li>
<li>Servlet mode</li>
<li>Applet mode</li>
</ul>

We'll outline these in this and the coming sections.
<p CLEAR="ALL"/>

BEASTShell is also integrated into a number of other tools and development
environments including the Emacs JDE and the NetBeans/Forte for Java IDE.
Please see the web site for articles and information about using BEASTShell
within these third party tools.

<h2><a name="Standalone">Standalone</a></h2>

<img src="../images/scriptmode.gif"/>
<br CLEAR="ALL"/>

You can use BEASTShell to run scripts from the command line or enter
statements interactively by starting the bsh.Interpreter class.
(See "Quickstart" for instructions on adding BEASTShell to your classpath.)
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
 java bsh.Interpreter [ filename ] [ arg ] [ ... ]  // Run a script file
</pre></td></tr></table></center><p/>

There are a few options which can be passed to the Interpreter using Java
system properties:

<ul>
<li><strong>outfile</strong> - Send all output to the specified file by 
redirecting System.out and System.err</li>

<li><strong>debug</strong> - Turn on debugging output by setting to
true.  <em>Note: this mode
is very verbose and unstructured.  It is not intended for general
use.</em></li>

<li><strong>trace</strong> - Setting trace to true turns on method tracing.  
This mode prints each line before it is executed.  <em>Note that this currently 
prints only top level lines as they are parsed and executed by the 
interpreter.  Trace skips over method executions (including bsh commands) 
etc.  This mode is incomplete.  It should be considered experimental.</em>
</li>
</ul>

<h2><a name="Remote">Remote</a></h2>

The bsh.Remote launcher is the equivalent of bsh.Interpreter, but runs
the specified file in a remote BEASTShell engine.  The remote engine may
be a servlet mode BEASTShell engine (BshServlet) or a native server mode 
remote BEASTShell instance (embedded interpreter).
<p CLEAR="ALL"/>

bsh.Remote accepts a URL and filename as arguments:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// servlet mode URL
java bsh.Remote http://localhost/bshservlet/eval test1.bsh

// remote server mode URL
java bsh.Remote bsh://localhost:1234/ test1.bsh
</pre></td></tr></table></center><p/>

An HTTP URL may be specified that points to an instance of BshServlet
(See "Servlet Mode" for details).  Or a native "bsh:" URL may be specified,
pointing to an instance of the BEASTShell interpreter running in remote
server mode.

<em>
At the time of this writing bsh: style URLs for accessing native remote
server mode instances are not implemented.
</em>
<p CLEAR="ALL"/>

In either case, bsh.Remote sends the script to the remote engine for
evaluation.  If Remote can parse the retun value of the script as an integer 
it will return the value as the exit status to the command line.  

<h2><a name="Interactive_Use">Interactive Use</a></h2>

One of the most popular uses for BEASTShell is, of course, as a "shell" for
interactive experimentation and debugging.  BEASTShell can be run in a GUI 
desktop mode that offers a number conveniences like command line history,
cut &amp; paste, and tools for interactive use such as a simple classbrowser.  
We'll talk about the GUI in "The BEASTShell Desktop" later.  

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
The BEASTShell GUI is comprised mostly of a set of BEASTShell scripts supplied 
in the JAR file and launched by the BEASTShell desktop() command.
</td></tr></table></center><p/>

However BEASTShell can also be run interactively in plain text on the command 
line.  

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
 java bsh.Interpreter   // Run interactively on the command line
</pre></td></tr></table></center><p/>

This is useful for quick "one liners"; however it does not offer 
creature comforts such as command line history and editing.  We should note
that some shells, such as the Windows environment, do command line history 
and editing automatically - providing these features for BEASTShell.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
You can exit from an interactive shell by typing Control-D.
</td></tr></table></center><p/>

The return statement is ignored in interactive mode (it does not exit the 
shell).
<p CLEAR="ALL"/>

<h2><a name="The_.bshrc_Init_File">The .bshrc Init File</a></h2>

When run interactively, BEASTShell looks for a startup file called ".bshrc"
in the user's home directory.  If the file is found it is sourced into the
interactive shell.  You can use this to perform setup for your interactive
use.  For example, to add additional default imports or to toggle on the
show() command if you prefer that.
<p CLEAR="ALL"/>

The location of the .bshrc file is determined by the Java system property
"user.home", which has different locations under different operating systems.
The following table lists common locations:

<h3>.bshrc File Location:</h3>

<table border="1" cellpadding="5">
<tr><td>Unix</td><td>$HOME/.bshrc</td></tr>

<tr><td>
Win95/98 single user
</td><td>
C:\Windows\.bshrc 
</td></tr>

<tr><td>
Win98 Multiuser
</td><td>
C:\Windows\Profiles\&lt;username&gt;\.bshrc
</td></tr>

<tr><td>
NT/2K
</td><td> 
C:\Winnt\Profiles\&lt;username&gt;\.bshrc
</td></tr>

</table>

<h1>Embedding BEASTShell in Your Application</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


<img src="../images/embeddedmode.gif"/>
<br CLEAR="ALL"/>

BEASTShell was designed not only as a standalone scripting language - to run
scripts from files or on the command line -  but to be easily embeddable in 
and extensible by your applications.  When we talk about
embedding BEASTShell in your application we mean simply that you can use the
BEASTShell Interpreter in your own classes, to evaluate scripts and work with
objects dynamically.  
<p CLEAR="ALL"/>

There are a number of reasons you might use BEASTShell in this way.  Here
are a few:
<p CLEAR="ALL"/>

<h3>Highly Customizable Applications</h3>

You can use BEASTShell to make your applications highly customizable by users 
without requiring them to compile Java classes or even to know all of the 
Java syntax.  

During development you can use BEASTShell to "factor out" volatile or 
environmentally dependent algorithms from your application and leave them 
in the scripting domain while they are under the most intense change.
Later it is easy to move them back into compiled Java if you wish because
BEASTShell syntax is Java syntax.
<p CLEAR="ALL"/>

<h3>Macros and Evaluation</h3>

BEASTShell can be used as a generic language for "macros" or other complex
tasks that must be described by a user of your application.
For example, the popular JEdit Java editor uses 
BEASTShell to allow users to implement macros for key bindings.  This gives
user power to customize the behavior of the editor, using as much (or
as little) of the full power of Java as desired.
<p CLEAR="ALL"/>

Java with loose variables is a very simple and appealing language; especially
because there is already so much Java out there.  Even a non-programmer
will be familiar with the name "Java" and more inclined to want to work
with it than an arbitrary new language.
<p CLEAR="ALL"/>

BEASTShell can also be used to perform dynamic evaluation of complex expressions
such as mathematics or computations entered by the user.   Why write an
arithmetic expression parser when you can let your user enter equations using
intermediate variables, operators, and other constructs.  If strict control
is desired, you can generate the script yourself using your own rules, and
still leave the evaluation to BEASTShell.

<h3>Simplify Complex Configuration Files</h3>

Many applications use simple Java properties files or XML for the majority
of their runtime configuration.
It is very common in the development of a large applications for configuration
files like this to become increasingly complex.  It can begin in a number
of seemingly harmless ways - with the desire to make "cross references"
inside the config files (XML supports this nicely).  Then comes the desire
to do something like variable substitution - which introduces some new syntax
such as "${variable}" and usually a second pass in the parsing stage.
Usually, at some point, integration with Java forces the introduction of 
class names into the mix.  The configuration files soon want to start
assigning parameters for object construction.  Ultimately what you'll 
discover is that you are creating your own scripting language - and one that
is probably not as easy to read as plain old Java.
<p CLEAR="ALL"/>

BEASTShell solves the problem of complex configuration files by allowing
users to work not only with simple properties style values 
(loose variable assignment)
but also to have the full power of Java to construct objects, arrays,
perform loops and conditionals, etc.  And as we'll see, BEASTShell scripts
can work seamlessly with objects from the application, <b>without</b>
the need to turn them into strings to cross the script boundary.
<p CLEAR="ALL"/>


<h2><a name="The_BEASTShell_Core_Distribution">The BEASTShell Core Distribution</a></h2>

Beanshell is fairly small, even in its most general distribution.  The
full JAR with all utilities weighs in at about 250K.  But BEASTShell is
also distributed in a componentized fashion, allowing you to choose to add
only the utilities and other pieces that you need.  The core distribution
includes only the BEASTShell interpreter and is currently about 130K.  <em>We
expect this size to drop in the future with improvements in the parser
generator.</em>  Any significant new features will always be provided in
the form of add-on modules, so that the core language can remain small.
<p CLEAR="ALL"/>

More and more people are using BEASTShell for embedded applications in small
devices.  We have reports of BEASTShell running everywhere from palm-tops
to autonomous buoys in the Pacific ocean!


<h2><a name="Calling_BEASTShell_From_Java">Calling BEASTShell From Java</a></h2>

Invoking BEASTShell from Java is easy.   The first step is to create in
instance of the bsh.Interpreter class.  Then you can use it to evaluate
strings of code, source external scripts.  You can pass your data in to
the Interpreter as ordinary BEASTShell variables, using the Interpreter
set() and get() methods.
<p CLEAR="ALL"/>

In "QuickStart" we showed a few examples:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import bsh.Interpreter;

Interpreter i = new Interpreter();  // Construct an interpreter
i.set("foo", 5);                    // Set variables
i.set("date", new Date() ); 

Date date = (Date)i.get("date");    // retrieve a variable

// Eval a statement and get the result
i.eval("bar = foo*10");             
System.out.println( i.get("bar") );

// Source an external script file
i.source("somefile.bsh");
</pre></td></tr></table></center><p/>

The default constructor for the Interpreter assumes that it is going to be
used for simple evaluation.  Other constructors allow you to
set up the Interpreter to work with interactive sources including streams
and the GUI console.
<p CLEAR="ALL"/>

<h2><a name="eval()">eval()</a></h2>

The Interprete eval() method accepts a script as a string and interprets it,
optionally returning a result.
The string can contain any normal BEASTShell script text with any number of 
Java statements.
The Interpreter maintains state over any number of eval() calls, so you can
interpret statements individually or all together.

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
It is not necessary to add a trailing ";" semi-colon at the end of the 
evaluated string.  BEASTShell always adds one at the end of the string.
</td></tr></table></center><p/>

The result of the evaluation of the last statement or expression in the 
evaluated string is returned as the value of the eval().  Primitive types
(e.g int, char, boolean) are returned wrapped in their primitive wrappers
(e.g. Integer, Character, Boolean).
If an evaluation of a statement or expression yields a "void" value; such
as would be the case for something like a for-loop or a void type method
invocation, eval() returns null.
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
Object result = i.eval( "long time = 42; new Date( time )" ); // Date
Object result = i.eval("2*2");  // Integer
</pre></td></tr></table></center><p/>

You can also evaluate text from a java.io.Reader stream using eval():

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
reader = new FileReader("myscript.bsh");
i.eval( reader );
</pre></td></tr></table></center><p/>

<h2><a name="EvalError">EvalError</a></h2>

The bsh.EvalError exception is the general exception type for an error in 
evaluating a BEASTShell script.  Subclasses of EvalError - ParseException
and TargetError - indicate the specific conditions where a textual 
parsing error was encountered or where the script itself caused an exception 
to be generated.
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
try {
    i.eval( script );
} catch ( EvalError e ) {
    // Error evaluating script
}
</pre></td></tr></table></center><p/>

You can get the error message, line number and source file of the error
from the EvalError with the following methods:
<p CLEAR="ALL"/>

<table border="1" cellpadding="5">
<tr><td>
String getErrorText() { 
</td></tr>
<tr><td>
int getErrorLineNumber() { 
</td></tr>
<tr><td>
String getErrorSourceFile() {
</td></tr>
</table>
<p CLEAR="ALL"/>

<h3>ParseException</h3>

ParseException extends EvalError and indicates that the exception was 
caused by a syntactic error in reading the script.  The error message will
indicate the cause.

<h3>TargetError</h3>

TargetError extends EvalError and indicates that the exception was 
not related to the evaluation of the script, but caused the by script itself.
For example, the script may have explicitly thrown an exception
or it may have caused an application level exception such as a NullPointer
exception or an ArithmeticException.
<p CLEAR="ALL"/>

The TargetError contains the "cause" exception.  You can retrieve it 
with the getTarget() method.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
try {
    i.eval( script );
} catch ( TargetError e ) {
    // The script threw an exception
    Throwable t = e.getTarget();
    print( "Script threw exception: " + t );
} catch ( ParseException e ) {
    // Parsing error
} catch ( EvalError e ) {
    // General Error evaluating script
}
</pre></td></tr></table></center><p/>

<h2><a name="source()">source()</a></h2>

The Interpreter source() method can be used to read a script from an external
file:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
i.source("myfile.bsh");
</pre></td></tr></table></center><p/>

The Interpreter source() method may throw FileNotFoundException and 
IOException in addition to EvalError.  Aside from that source() is simply
and eval() from a file.

<h3>set(), get(), and unset()</h3>

As we've seen in the examples thus far, set() and get() can be used to
pass objects into the BEASTShell interpreter as variables and retrieve the
value of variables, respectively.
<p CLEAR="ALL"/>

It should be noted that get() and set() are capable of evaluation of
arbitrarily complex or compound variable and field expression.  
For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import bsh.Interpreter;
i=new Interpreter();

i.eval("myobject=object()" );
i.set("myobject.bar", 5);

i.eval("ar=new int[5]");
i.set("ar[0]", 5);

i.get("ar[0]");
</pre></td></tr></table></center><p/>

The get() and set() methods have all of the evaluation capabilities of
eval() except that they will resolve only one variable target or value
and they will expect the expression to be of the appropriate resulting type.
<p CLEAR="ALL"/>

<em>The deprecated setVariable() and getVariable() methods are no longer
used because the did not allow for complex evaluation of variable names</em>
<p CLEAR="ALL"/>

You can use the unset() method to return a variable to the undefined state.


<h3>Getting Interfaces from Interpreter</h3>

We've talked about the usefulness of writing scripts that implement
Java interfaces.  By wrapping a script in an interface you can make it
transparent to the rest of your Java code.

As we described in the "Interfaces" section earlier, within the BEASTShell 
interpreter scripted objects automatically implement any interface necessary 
when they are passed as arguments to methods requiring them.  
However if you are going to pass a reference outside of BEASTShell you may 
have to perform an explicit cast inside the script, to get it to manufacture 
the correct type.
<p CLEAR="ALL"/>

The following example scripts a global actionPerformed() method and returns a
reference to itself as an ActionListener type:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// script the method globally
i.eval( "actionPerformed( e ) { print( e ); }");

// Get a reference to the script object (implementing the interface)
ActionListener scriptedHandler = 
    (ActionListener)i.eval("return (ActionListener)this");

// Use the scripted event handler normally...
new JButton.addActionListener( scriptedHandler );
</pre></td></tr></table></center><p/>

Here we have performed the explicit cast in the script as we returned the
reference.  (And of course we could have used the standard Java anonymous
inner class style syntax as well.)
<p CLEAR="ALL"/>

An alternative would have been to have used the Interpreter getInterface()
method, which asks explicitly for the global scope to be cast to a specific
type and returned.
The following example fetches a reference to the interpreter global namespace 
and cast it to the specified type of interface type.  

<pre>
Interpreter interpreter = new Interpreter();
// define a method called run()
interpreter.eval("run() { ... }");

// Fetch a reference to the interpreter as a Runnable
Runnable runnable =
    (Runnable)interpreter.getInterface( Runnable.class );
</pre>
<p CLEAR="ALL"/>

The interface generated is an adapter (as are all interpreted interfaces).  
It does not interfere with other uses of the global scope or other 
references to it.
We should note also that the interpreter does *not* require that any or all 
of the methods of the interface be defined at the time the interface is
generated.  However if you attempt to invoke one that is not defined
you will get a runtime exception.
<p CLEAR="ALL"/>

<h2><a name="Multiple_Interpreters_vs._Multi-threading">Multiple Interpreters vs. Multi-threading</a></h2>

A common design question is whether to use a single BEASTShell
interpreter or multiple interpreter instances in your application.  
<p CLEAR="ALL"/>

The Interpreter class is, in general, thread safe and allows you to 
work with threads, within the normal bounds of the Java language.  BEASTShell
does not change the normal application level threading issues of multiple 
threads from accessing the same variables: you still have to synchronize
access using some mechanism if necessary. 
However it is legal to perform multiple simultaneous evaluations. 
You can also write multi-threaded scripts within the language, as we discussed
briefly in "Scripting Interfaces".
<p CLEAR="ALL"/>

Since working with multiple threads introduces issues of synchronization
and application structure, you may wish to simply create multiple Interpreter
instances.  BEASTShell Interpreter instances were designed to be very light
weight.  Construction time is usually negligible and in simple tests, we have 
found that it is possible to maintain hundreds (or even thousands) of 
instances.
<p CLEAR="ALL"/>

There are other options in-between options as well.  It is possible to 
retrieve BEASTShell scripted objects from the interpreter and "re-bind" them
again to the interpreter.  We'll talk about that in the next section.
You can also get and set the root level bsh.NameSpace object for the
entire Interpreter.  The NameSpace is roughly equivalent to a BEASTShell method
context.   Each method context has an associated NameSpace object.

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
You can clear all variables, methods, and imports from a scope using
the clear() command.
</td></tr></table></center><p/>


<em>Note: at the time of this writing the synchronized language keyword
is not implemented.  This will be corrected in an upcoming release.</em>
<p CLEAR="ALL"/>

See also "The BEASTShell Parser" for more about performance issues.

<h2><a name="Serializing_Interpreters_and_Scripted_Objects">Serializing Interpreters and Scripted Objects</a></h2>

The BEASTShell Interpreter is serializable, assuming of course that all
objects referenced by variables in the global scope are also serializable.
So you can save the entire static state of the interpreter by serializing
it and storing it.  Note that serializing the Intepreter does not "freeze"
execution of BEASTShell scripts in any sense other than saving the current
state of the variables.  In general if you serialize an Interpreter while 
it is executing code the results will be undetermined.  De-serializing an
interpreter does not automatically restart method executions; it simply
restores state.
<p CLEAR="ALL"/>

It is also possible to serialize individual BEASTShell scripted objects
('this' type references and interfaces to scripts).  The same rules apply.
One thing to note is that by default serializing a scripted object context
will also serialize all of that object's parent contexts up to the global
scope - effectively serializing the whole interpreter.
<p CLEAR="ALL"/>

To detach a scripted object from its parent namespace you can use the
namespace prune() method:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// From BEASTShell
object.namespace.prune();

// From Java
object.getNameSpace().prune();
</pre></td></tr></table></center><p/>

To bind a BEASTShell scripted object back into a particular method scope
you can use the bind() command:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// From BEASTShell
bind( object, this.namespace );

// From Java
bsh.This.bind( object, namespace, interpreter );
</pre></td></tr></table></center><p/>

The bind() operation requires not only the namespace (method scope) into which 
to bind the object, but an interpreter reference as well.  The interpreter
reference is the "declaring interpreter" of the object and is used for cases
where there is no active interpreter - e.g. where an external method call
from compiled Java enters the object.
<p CLEAR="ALL"/>

The BEASTShell save() command which serializes objects recognize when you are 
trying to save a BEASTShell scripted object (a bsh.This reference) type and 
automatically prune()s it from the parent namespace, so that saving the object 
doesn't drag along the whole interpreter along for the ride.  Similarly, 
load() binds the object to the current scope.
<p CLEAR="ALL"/>


<h1>Remote Server Mode</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


<img src="../images/remotemode.gif"/>
<br CLEAR="ALL"/>

Remote server mode lets you access a BEASTShell Interpreter inside of a 
remote VM.
With remote server mode activated you can literally telnet into the running
application and type commands at the BEASTShell shell prompt.  Or, even better, 
you can use any web browser to bring up a remote GUI console.
<p CLEAR="ALL"/>


<p CLEAR="ALL"/>
<center>
<table width="90%" border="1" cellpadding="5">
<tr><td>
<strong>Warning:</strong>
<br CLEAR="ALL"/>
<b>When activated remote server mode can provide unrestricted access
to all parts of your application and the host server.  This mode should
not be used in production environments or anywhere that server security
is an issue.
</b>
</td></tr>
</table>
</center>
<p CLEAR="ALL"/>

To enable remote access simply issue the BEASTShell server() command, specifying
a base port number:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
server(1234);
// Httpd started on port: 1234
// Sessiond started on port: 1235
</pre></td></tr></table></center><p/>

At this point BEASTShell will run two services: a tiny HTTP server on the
port you specified and the BEASTShell telnet session server on the next port
(the port you specified + 1).
<p CLEAR="ALL"/>

<h2><a name="Web_Browser_Access">Web Browser Access</a></h2>

After starting the server you can connect your web browser to the port
you specified.   BEASTShell will respond by sending an HTML page offering
you a choice of the Swing based JConsole or the older AWTConsole.  You
may choose whichever is appropriate for your web browser.
<p CLEAR="ALL"/>

You can skip this decision page by hitting one of the following URLs directly:

<table border="1" cellpadding="5">

<tr><td>http://&lt;yourserver&gt;:&lt;port&gt;/remote/jconsole.html</td><td>
Swing based JConsole page
</td></tr>

<tr><td>http://&lt;yourserver&gt;:&lt;port&gt;/remote/awtconsole.html</td><td>
Minmal (old) AWT based Console page
</td></tr>

</table>

The httpd server then serves the remote console applet.
When it starts you will have a BEASTShell session that looks like the 
regular console, but is connected to the remote BEASTShell VM.
<p CLEAR="ALL"/>

<img src="../images/remoteconsole.gif"/>
<p CLEAR="ALL"/>

You can open as many sessions into that VM as you like in this way, but 
note that unlike the BEASTShell desktop environment -
<strong>
All remote sessions share the same global scope.
</strong>
You are effectively working in the same interpreter instance for all 
connections.  This is intended as a feature, as the primary usefulness of
this mode is for debugging.  You can set variables and access components
across many sessions.
<p CLEAR="ALL"/>

<h2><a name="Example">Example</a></h2>

Let's look at a quick example of how you might start a remote session from
within your application:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// Java code
import bsh.Interpreter;
i = new Interpreter();

i.set( "myapp", this );  // Provide a reference to your app
i.set( "portnum", 1234 );  
i.eval("setAccessibility(true)"); // turn off access restrictions

i.eval("server(portnum)"); 
</pre></td></tr></table></center><p/>

Here we have set up the interpreter instance just as we would to do any
other kind of scripting - passing in Java objects using set().  In this case
we passed a general reference to our application using 'this', as well.
We have turned on accessibility so that we can access private and protected
members of our classes (useful for debugging).  Finally we start the server
on the desired port.

<h2><a name="Telnet_Access">Telnet Access</a></h2>

We mentioned earlier that BEASTShell starts its telnet session server on
the port next to the HTTP port.  You can use any telnet client to access
a BEASTShell command line directly, in text only-mode, without the use of
a web browser.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
telnet &lt;myhost&gt; &lt;port+1&gt;
</pre></td></tr></table></center><p/>

Note that this command line is not very friendly.  In particular it does not
respond to gratuitous newlines with a new prompt (as the text only 
Interpreter command line does).
<p CLEAR="ALL"/>

<em>
At the time of this writing there is no explicit way to close a session.
BEASTShell will simply detect the end of streams.
</em>

<h1>BshServlet and Servlet Mode Scripting</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


BshServlet is a simple servlet that can be used to evaluate BEASTShell
scripts inside of an application server or servlet container.  BshServlet
accepts BEASTShell scripts via the POST method, evaluates them capturing output
(optionally including standard out and standard error) and returns the results.
<p CLEAR="ALL"/>

BshServlet has a simple form based interface for interactive experimentation
(analogous to the remote server mode).  But more generally you can send
standalone BEASTShell scripts from the command line to the BshServlet for
evaluation using the bsh.Remote launcher.  bsh.Remote complements
bsh.Interpreter and bsh.Console as a launch point for BEASTShell.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
You may find BshServlet useful for writing unit tests that must run inside an
application server environment.  In this mode BshServlet can be used
in the same way as or in combination with the Jakarta project's cactus.
</td></tr></table></center><p/>

<h2><a name="Deploying_BshServlet">Deploying BshServlet</a></h2>

To test drive BshServlet you can grab one of the following sample application 
WAR files here:

<ul>
<li><a href="http://www.beanshell.org/bshservlet.war">
http://www.beanshell.org/bshservlet.war</a></li>
<li>
<a href="http://www.beanshell.org/bshservlet-wbsh.war">
http://www.beanshell.org/bshservlet-wbsh.war</a> 
<em>Rename this file to "bshservlet.war" for use.</em>
</li>
</ul>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
A WAR file is a Web Application Archive.  It is a JAR file containing HTML,
images, servlets, and configuration files comprising a complete web 
application.  Web applications can usually be deployed to a servlet container by
simply dropping the WAR file into a special directory.
</td></tr></table></center><p/>

The first file, bshservlet.war, assumes that BEASTShell has been installed in 
your application server's classpath.  It includes only the web.xml file 
necessary to deploy an instance of the test servlet and an index.html README 
file.  

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
To install BEASTShell in the Tomcat server classpath place the bsh.jar file in 
common/lib.  To use BEASTShell in Weblogic you must upgrade its version of the 
package.  See <a href="weblogic.html">Upgrading BEASTShell in Weblogic</a>
(http://www.beanshell.org/weblogic.html).
</td></tr></table></center><p/>

The second WAR, bshservlet-wbsh.war, includes a copy of the BEASTShell 
application bsh.jar inside the WAR's lib directory.  This WAR includes 
everything you need to just drop the WAR into an application server.  

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
Using bshservlet-wbsh.war will still *not* work in Weblogic 6.x unless 
you upgrade Weblogic's internal version of BEASTShell first.  
See <a href="weblogic.html">Upgrading BEASTShell in Weblogic</a>.
(http://www.beanshell.org/weblogic.html).
</td></tr></table></center><p/>

To use the servlet for testing your own applications you will probably want to
deploy an instance of the test servlet in your WAR file.  This will allow 
the test servlet to to share a classloader with your webapp so that you can 
test things like application classes and EJB local homes.  Since the servlet 
is included in the standard BEASTShell distribution, all that is necessary to 
do this is to include bsh.jar and add an entry to your wegapp's web.xml file.  
Here is an example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre> 
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!DOCTYPE web-app
    PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
    "http://java.sun.com/dtd/web-app_2_3.dtd"&gt;

&lt;web-app&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;bshservlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;bsh.servlet.BshServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;bshservlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/eval&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</pre></td></tr></table></center><p/>

The above example deploys an instance of BshServlet under the name "/eval".
The full path to the servlet will then depend on the name given to the
webapp WAR file.  For example if the above appears in a WAR file named
"myapp.war" then the path would be:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
http://localhost/myapp/eval
</pre></td></tr></table></center><p/>

<h2><a name="Running_Scripts">Running Scripts</a></h2>

After deploying the servlet, test it by fetching the default page with 
your web browser.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
http://localhost/bshservlet/eval
</pre></td></tr></table></center><p/>

You can use the servlet interactively through the form that it generates, or,
more importantly, through the command line launcher bsh.Remote.
bsh.Remote accepts a URL for a target bsh interpreter 
and one or more file names to send to that server, printing the results.  

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
  java bsh.Remote http://localhost/bshservlet/eval test1.bsh
</pre></td></tr></table></center><p/>

You can execute remote scripts programmatically using the static method 
bsh.Remote.eval().
<p CLEAR="ALL"/>

If bsh.Remote can parse the retun value as an integer it will 
return it as the exit status to the command line.  
<p CLEAR="ALL"/>

<h2><a name="The_Script_Environment">The Script Environment</a></h2>

Scripts have access to the servlet environment through two predefined variables:

<ul>
<li>bsh.httpServletRequest</li>
<li>bsh.httpServletResponse</li>
</ul>

which are the standard servlet request and response objects, respectively.
<p CLEAR="ALL"/>

When set to "raw" output mode via the forms interface or servlet parameter
(described in the next section) the script is expected to generate the 
complete response using the httpServletResponse object.  This means that you 
can have your script generate HTML or other output to be consumed by the client.

For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre> 
// Server side script generates HTML response page
bsh.httpServletResponse.setContentType("text/html");
out = bsh.httpServletResponse.getWriter();
out.println("&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;");
</pre></td></tr></table></center><p/>

More generally, you can use the httpServletRequest to get access to the
server environment such as the servlet session object.  You can also access
all of the standard Java tools such as JNDI to fetch EJB homes, etc. and
perform testing or script activities.

<h2><a name="BshServlet_Parameters">BshServlet Parameters</a></h2>

The following parameters are recognized by BshServlet:

<table border="1" cellpadding="5">
<tr><td>Parameter</td><td>Value</td></tr>
<tr><td><strong>bsh.script</strong></td><td>The BEASTShell Script</td></tr>
<tr><td><strong>bsh.servlet.captureOutErr</strong></td><td>"true" - 
capture standard out and standard error during the evaluation of the 
script.  Note: this is inherently non-thread safe.  All output from the
VM will be captured.
</td></tr>
<tr><td><strong>bsh.servlet.output</strong></td><td>"raw" - Do not generate
the servlet HTML result page.  Instead rely on the script to generate the
complete result using the servlet response.
<tr><td><strong>bsh.client</strong></td><td>"remote" - set by the bsh.Remote
launcher to indicate that results should be raw and the return value should
be encoded for transport back to the client.</td></tr>
</td></tr>
</table>

<h1>The BEASTShell Parser</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


This BEASTShell parser class bsh.Parser is used internally by the BEASTShell
Interpreter.  It is responsible for the lexical parsing of the input text,
the application of the grammar structure, and the building of an internal
representation of the BEASTShell script file called an "abstract syntax tree" 
(AST).
<p CLEAR="ALL"/>

The Parser just analyzes the language syntax.  It knows only how to parse the 
structure of the language - it does not interpret names, or execute methods 
or commands.  You can use the Parser directly if you have a need to 
analyze the structure of BEASTShell scripts or Java methods and statements
in general.
<p CLEAR="ALL"/>

<h2><a name="Validating_Scripts_With_bsh.Parser">Validating Scripts With bsh.Parser</a></h2>

You can use the Parser class from the command line to do basic structural 
validation of BEASTShell files without actually executing them. e.g.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
java bsh.Parser [ -p ] file [ file ] [ ... ]
</pre></td></tr></table></center><p/>

The -p option causes some of the abstract syntax to be printed.
<p CLEAR="ALL"/>

The parser will detect any syntax errors in the script and print an error.
Note again that names, imports, and string evaluations are analyzed only for
syntax - not content or meaning.
<p CLEAR="ALL"/>

<h2><a name="Parsing_and_Performance">Parsing and Performance</a></h2>

It is useful to have a high level understanding how BEASTShell works
with scripts to understand performance issues.
<p CLEAR="ALL"/>

The first time a script is read or sourced into an interpreter, 
BEASTShell uses the parser to parse the script internally to an AST.
The AST consists of Java object representations of all of the language
structures and objects.  The AST consists of Java classes, but is 
<em>not</em> the same as compiled Java code.  When the script is "executed"
BEASTShell steps through each element of the AST and tells it to perform
whatever it does (e.g. a variable assignment, for-loop, etc.).  
This execution of the ASTs is generally much faster than the original parsing 
of the text of the method.  It is really only limited by the speed of the
application calls that it is making, the speed of the Java reflection API,
and the efficiency of the implementation of the structures in BEASTShell.
<p CLEAR="ALL"/>

When parsing "line by line" through a BEASTShell script the ASTs are routinely
executed and then thrown away.  However the case of a BEASTShell method
declaration is different.  A BEASTShell method is parsed only once: when it
is declared in the script.  It is then stored in the namespace like any
variable.  Successive invocations of the method execute the ASTs again, but
do not re-parse the original text.
<p CLEAR="ALL"/>

This means that successive calls to the same scripted method are as fast
as possible - much faster than re-parsing the script each time.  
You can use this to your advantage when
running the same script many times simply by wrapping your code in the form
of a BEASTShell scripted method and executing the method repeatedly, rather
than sourcing the script repeatedly.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// From Java
import bsh.Interpreter;
i=new Interpreter();

// Declare method or source from file
i.eval("foo( args ) { ... }");

i.eval("foo(args)"); // repeatedly invoke the method
i.eval("foo(args)");
...
</pre></td></tr></table></center><p/>

In the above example we defined a method called foo() which holds our 
script.  Then we executed the method repeatedly.  The foo() method was
parsed only once: when its declaration was evaluated.  Subsequent invocations
simply execute the AST.

<h2><a name="Parsing_Scripts_Procedurally">Parsing Scripts Procedurally</a></h2>

If you are willing to learn about the BEASTShell abstract syntax tree classes
you can use the Parser to parse a BEASTShell script into its ASTs like this:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
in=new FileReader("somefile.bsh");
Parser parser = new Parser(in);
while( !(eof=parser.Line()) ) {
    SimpleNode node = parser.popNode();
    // Use the node, etc. (See the bsh.BSH* classes)
    ...
}
</pre></td></tr></table></center><p/>

To learn more about the abstract syntax tree please download the source
distribution and consult the source documentation.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
The bshdoc.bsh script uses the parser to extract method signatures
and comments from a BEASTShell file.  Check it out for a more realistic
example.
</td></tr></table></center><p/>

<em>Note: Many components of the AST classes are not public at this time.
Use setAccessibility(true) to access them.</em>

<h1>Reflective Style Access to Scripted Methods</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


The following examples show how to work with BEASTShell methods dynamically 
from within scripts, using the equivalent of reflective style access in Java.
This is an advanced topic primarily of interest to developers who wish to
do tight integration of BEASTShell scripts with their application environment.
<p CLEAR="ALL"/>

<h2><a name="eval()">eval()</a></h2>

The simplest form of reflective style access to scripts is through the 
eval() command.  With eval() you can evaluate any text just as if it had 
appeared in the current scope.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
eval("a=5;");
print( a ); // 5
</pre></td></tr></table></center><p/>

So, if you know the signature (argument types) of a method you wish to work 
with you can simply construct a method call as a string and evaluate it 
with eval() as in the following:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// Declare methods foo() and bar( int, String )
foo() { ... }
bar( int arg1, String arg2 ) { ... }

// Invoke a no-args method foo() by its name using eval()
name="foo";
// invoke foo() using eval()
eval( name+"()");

// Invoke two arg method bar(arg1,arg2) by name using eval()
name="bar";
arg1=5;
arg2="stringy";
eval( name+"(arg1,arg2)");
</pre></td></tr></table></center><p/>

You can get the names of all of the methods defined in the current scope
using the 'this.methods' magic reference, which returns an array of Strings:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// Print the methods defined in this namespace
print( this.methods );
</pre></td></tr></table></center><p/>

We'll talk about more powerful forms of method lookup in a moment.

<h2><a name="invokeMethod()">invokeMethod()</a></h2>

You can explicitly invoke a method by name with arguments through a 'this' 
type reference using the invokeMethod() method:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
this.invokeMethod( "bar", new Object [] { new Integer(5), "stringy" } );
</pre></td></tr></table></center><p/>

Arguments are passed as an array of objects.  Primitive types must be 
wrapped in their appropriate wrappers.
BEASTShell will select among overloaded methods using the standard Java
method resolution rules.  (JLS 15.11.2).

<h2><a name="Method_Lookup">Method Lookup</a></h2>

The previous section showed how to invoke a method by name when we know
the argument types.  Of course, in general we'd like to be able to find out
what methods are defined in the current script or to look up a method by
its signature.
<p CLEAR="ALL"/>

You can get "handles" to all of the methods defined in a context using the 
namespace getMethods() method.  
getMethods() returns an array of bsh.BshMethod objects,
which are wrappers for the internally parsed representation of BEASTShell
scripted methods:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() { ... }
foo( int a ) { ... }
bar( int arg1, String arg2 ) { ... }

print ( this.namespace.getMethods() );

// Array: [Lbsh.BshMethod;@291aff {
//   Bsh Method: bar
//   Bsh Method: foo
//   Bsh Method: foo
// }
</pre></td></tr></table></center><p/>

We'll talk about what you can do with a BshMethod in a moment.
<p CLEAR="ALL"/>

Alternately, you can use the namespace getMethod() method to search 
for a specific method signature.  The method signature is a set of argument 
types represented by an array of Classes:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
name="bar";
signature = new Class [] { Integer.TYPE, String.class };

// Look up a method named bar with arg types int and String
bshMethod = this.namespace.getMethod( name, signature );

print("Found method: "+bshMethod);
</pre></td></tr></table></center><p/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
The Java reflection API uses special class values to represent primitive types
such as int, char, an boolean.  These types are static fields in the respective
primitive wrapper classes.  e.g. Integer.TYPE, Character.TYPE, Boolean.TYPE.
</td></tr></table></center><p/>

In the above snippet we located the bar() method by its signature.  If there
had been overloaded forms of bar() getMethod() would have located the most
specific one according to the standard Java method resolution rules 
(JLS 15.11.2).
The result of the lookup is a bsh.BshMethod object, as before.
<p CLEAR="ALL"/>

<h2><a name="BshMethod">BshMethod</a></h2>

You can inspect a BshMethod object to determine its method name and
argument types:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
name = bshMethod.getName();
Class [] types = bshMethod.getArgumentTypes();
Class returnType = bshMethod.getReturnType();
</pre></td></tr></table></center><p/>

To invoke the BshMethod, call its invoke() method, passing an array of 
arguments, an interpreter reference, and a "callstack" reference.
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// invoke the method with arg
bshMethod.invoke( new Object [] { new Integer(1), "blah!" }, 
    this.interpreter, this.callstack );
</pre></td></tr></table></center><p/>

For the
interpreter and callstack references you can simply pass along the current
context's values via 'this.interpreter' and 'this.callstack', as we did
above.  The arguments array may be null or empty for no arguments.
<p CLEAR="ALL"/>



<h2><a name="Uses">Uses</a></h2>

Why would anyone want to do this?  Well, perhaps you are sourcing a script
created by a user and want to automatically begin using methods that they
have defined.  Perhaps the user is allowed to define methods to take control 
of various aspects of your application.  With the tools we've described
in this section you can list the methods they have defined and invoke
them dynamically.

<h1>Executable scripts under Unix</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


You can use BEASTShell for writing scripts as you would any other shell 
under many Unixs:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
#!/usr/java/bin/java bsh.Interpreter 

print("foo");
</pre></td></tr></table></center><p/>

However some flavors of Unix are more picky about what they will allow
as a shell program.  For those you can use the following hack to make
your BEASTShell scripts executable.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
#!/bin/sh
# The following hack allows java to reside anywhere in the PATH.
//bin/true; exec java bsh.Interpreter "$0" "$@"

print("foo");
</pre></td></tr></table></center><p/>

The above trick presumes that /bin/true exists on your system and that //bin is
the same as /bin.  The // causes BEASTShell to ignore the line.
<p CLEAR="ALL"/>

The above has been tested on Solaris.  It does not seem to work under Cygwin.

<h3>OSX</h3>

For OSX the path is a bit different:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
#!/Library/Java/home/bin/java bsh.Interpreter

print("foo");
</pre></td></tr></table></center><p/>

On OSX /usr/bin/java is itself a shell script, which unfortunately won't
work out-of-the-box.

<h1>BSF Bean Scripting Framework</h1>by Pat Niemeyer <a href='mailto:pat@pat.net'>pat@pat.net</a></p>


BSF is the Apache "Bean Scripting Framework".  
It is generic framework that allows
many scripting languages to be plugged into an application.  It shields
the application from knowledge of how to invoke the scripting languages and
their APIs, via adapter "engines". 
<p CLEAR="ALL"/>

BEASTShell supports the BSF API by providing the necessary adapter.  
This means that BEASTShell can be used as a scripting language for any BSF
2.3 capable application simply by dropping the bsh JAR file into the classpath.
<p CLEAR="ALL"/>

Prior to version 2.3, BSF was maintained by IBM.  
To get BEASTShell to work with older versions of BSF you must use the 
older bsh-bsf-1.2x.jar file which includes the adapter class for the previous
ibm packaged BSF API.
You must also explicitly register the BEASTShell adapter with older versions
of BSF.  Here is an example of how to do that:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import com.ibm.bsf.*;

// register beanshell with the BSF framework
String [] extensions = { "bsh" };
BSFManager.registerScriptingEngine(
    "beanshell", "bsh.util.BEASTShellBSFEngine", extensions );
</pre></td></tr></table></center><p/>


See 
<a href="http://jakarta.apache.org/bsf/">http://jakarta.apache.org/bsf/</a> 
and
<a href="http://oss.software.ibm.com/developerworks/projects/bsf">
http://oss.software.ibm.com/developerworks/projects/bsf</a> 

for more information about BSF.

<h2><a name="Ant">Ant</a></h2>

<em>This section needs to be updated.  I'm not sure what versionf of Ant use
the new and which use the old BSF API.</em>
<p CLEAR="ALL"/>

Ant 1.5+ has explicit support for BEASTShell as a BSF scripting language.
The BEASTShell JAR file includes the necessary BSF adapter.  You must
simply specify language="beanshell" in your script tags.

<h3>Installation</h3>

To use BEASTShell within Ant you must do two things:
<ol>
<li>Add the
<a href="http://oss.software.ibm.com/developerworks/projects/bsf">
BSF bsf.jar file</a>
to ANT_HOME/lib or the classpath.</li>
<li>Add the 
<a href="http://www.beanshell.org/download.html">
BEASTShell bsh.jar file</a>
to ANT_HOME/lib or the classpath.</li>
</ol>
<p CLEAR="ALL"/>

You can then run scripts from a file, or in-line like so:
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
&lt;project name="testbsh" default="runscript" basedir="."&gt;
    &lt;target name="runscript"&gt;

        &lt;!-- Run script from a file --&gt;
        &lt;script language="beanshell" src="myscript.bsh"/&gt;

        &lt;!-- Run script in-line --&gt;
        &lt;script language="beanshell"&gt;&amp;lt;![CDATA[
            for(int i=0; i&lt;10; i++ )
                print( "i="+i );
        ]]&amp;gt;&lt;/script&gt;

    &lt;/target&gt;
&lt;/project&gt;
</pre></td></tr></table></center><p/>


<h1>Credits and Acknowledgments</h1>

BEASTShell is based on <a href='http://code.google.com/p/beanshell2'>BeanShell 2.2</a>
which is based on <a href='http://www.beanshell.org'>BeanShell</a>.
Many people have contributed substantially to BeansShell
and thus BEASTShell over the years. Pat Niemeyer (pat@pat.net) is the inventor of Beanshell 
and graciously made it an open source project to build on. Thanks to Daniel Leuck for his 
long time support and many contributions to the project.</p>

Thanks to the people at the beanshell2 google code project, 
fschm...@gmail.com,
pejob...@gmail.com ,
dlee.cal...@gmail.com, 
Daniel.K...@gmail.com, 
seth.ly...@gmail.com, 
He.Dingwei, 
cresw...@gmail.com, 
alexande...@gmail.com, 
matthew....@gatech.edu, 
jesse...@gmail.com, 
dilum.ra...@gmail.com, 
bill.ms....@gmail.com, 
sstevens...@gmail.com, 
apsh...@gmail.com, 
verilo...@gmail.com
for ongoing development of BeanShell.</p>

BEASTShell is a <a href='http://beast2.org'>BEAST</a>-package that uses 
code from
<ul>
<li> <a href='http://www.renjin.org/'>Renjin</a> for its distribution and mathematical
commands. Documentation for these commands was copied from the <a href='http://www.r-project.org/'>R-project</a>.
<li> <a href='https://code.google.com/p/beast-graphics/'>beast-graphics</a> for drawing trees,
<li> rsyntaxarea and code completion from <a href='http://fifesoft.com/rsyntaxtextarea/'>FifeSoft</a>,
<li> XChart, a lightweight Java library for 2D plotting from <a href='https://github.com/timmolter/XChart/'>github</a>,
<li> <a href='http://itextpdf.com/'>itextpdf</a> for exporting charts to pdf.
</ul>

<p CLEAR="ALL"/>

<h2><a name="License_and_Terms_of_Use">License and Terms of Use</a></h2>

You may freely use and reproduce this document in its entirety as long as 
you preserve this license information and a pointer to the original
web site: http://www.beanshell.org.  You may integrate parts of this document
into your own documentation as long as you provide this same information 
at an appropriate place in your document.
<p CLEAR="ALL"/>

This document is copyright Pat Niemeyer, 2002.  Sections contributed by
other authors are copyrighted to those individuals and subject to the
terms of use described above.
<p CLEAR="ALL"/>

<h2><a name="Disclaimer">Disclaimer</a></h2>
I (Remco) tried to make the documentation as accurate and complete as possible, while
trying to be efficient with time and reusing work from the people mentioned above.
Undoubtedly there are many errors, which are completely to blame on me. If you find 
such an error, I would appreciate it if you could drop me a line to 
<a href="mailto:remco@cs.auckland.ac.nz">remco@cs.auckland.ac.nz</a>.
Thanks a lot!


</body></html>
</body></html>
