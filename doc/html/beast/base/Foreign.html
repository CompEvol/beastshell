<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Foreign Function Interface</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="R.css">
</head><body>

<table width="100%" summary="page for Foreign {base}"><tr><td>Foreign {base}</td><td align="right">R Documentation</td></tr></table>

<h2>Foreign Function Interface</h2>

<h3>Description</h3>

<p>Functions to make calls to compiled code that has been loaded into <font face="Courier New,Courier" color="#666666"><b>R</b></font>.
</p>


<h3>Usage</h3>

<pre>
       .C(.NAME, ..., NAOK = FALSE, DUP = TRUE, PACKAGE, ENCODING)
 .Fortran(.NAME, ..., NAOK = FALSE, DUP = TRUE, PACKAGE, ENCODING)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>.NAME</code></td>
<td>
<p>a character string giving the name of a C function or
Fortran subroutine, or an object of class
<code>"<a href="getNativeSymbolInfo.html">NativeSymbolInfo</a>"</code>, <code>"<a href="getNativeSymbolInfo.html">RegisteredNativeSymbol</a>"</code>
or <code>"<a href="getNativeSymbolInfo.html">NativeSymbol</a>"</code> referring to such a name.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>arguments to be passed to the foreign function.  Up to 65.</p>
</td></tr>
<tr valign="top"><td><code>NAOK</code></td>
<td>
<p>if <code>TRUE</code> then any <code><a href="NA.html">NA</a></code> or
<code><a href="is.finite.html">NaN</a></code> or <code><a href="is.finite.html">Inf</a></code> values in the arguments are
passed on to the foreign function.  If <code>FALSE</code>, the presence of
<code>NA</code> or <code>NaN</code> or <code>Inf</code> values is regarded as an error.</p>
</td></tr>
<tr valign="top"><td><code>DUP</code></td>
<td>
<p>if <code>TRUE</code> then arguments are duplicated if necessary
before their addresses are passed to C or Fortran.</p>
</td></tr>
<tr valign="top"><td><code>PACKAGE</code></td>
<td>
<p>if supplied, confine the search for a character string
<code>.NAME</code> to the DLL given by this argument (plus the
conventional extension, &lsquo;<span class="file">.so</span>&rsquo;, &lsquo;<span class="file">.dll</span>&rsquo;, ...).
</p>
<p>This is intended to add safety for packages, which can ensure by
using this argument that no other package can override their external
symbols, and also speeds up the search (see &lsquo;Note&rsquo;).</p>
</td></tr>
<tr valign="top"><td><code>ENCODING</code></td>
<td>
<p>For back-compatibility, accepted but ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used to make calls to compiled C and Fortran 77
code.  Later interfaces are <code><a href="CallExternal.html">.Call</a></code> and
<code><a href="CallExternal.html">.External</a></code> which are more flexible and have better
performance.
</p>
<p>These functions are <a href="Primitive.html">primitive</a>, and <code>.NAME</code> is always
matched to the first argument supplied (which should not be named).
The other named arguments follow <code>...</code> and so cannot be
abbreviated.  For clarity, should avoid using names in the arguments
passed to <code>...</code> that match or partially match <code>.NAME</code>.
</p>


<h3>Value</h3>

<p>A list similar to the <code>...</code> list of arguments passed in
(including any names given to the arguments), but reflecting any
changes made by the C or Fortran code.
</p>


<h3>Argument types</h3>

<p>The mapping of the types of <font face="Courier New,Courier" color="#666666"><b>R</b></font> arguments to C or Fortran arguments is
</p>

<table summary="Rd table">
<tr>
 <td align="left">
    <font face="Courier New,Courier" color="#666666"><b>R</b></font> </td><td align="left">     C </td><td align="left">     Fortran</td>
</tr>
<tr>
 <td align="left">
    integer </td><td align="left"> int * </td><td align="left"> integer</td>
</tr>
<tr>
 <td align="left">
    numeric </td><td align="left"> double * </td><td align="left"> double precision</td>
</tr>
<tr>
 <td align="left">
    -- or -- </td><td align="left"> float * </td><td align="left"> real</td>
</tr>
<tr>
 <td align="left">
    complex </td><td align="left"> Rcomplex * </td><td align="left"> double complex</td>
</tr>
<tr>
 <td align="left">
    logical </td><td align="left"> int * </td><td align="left"> integer </td>
</tr>
<tr>
 <td align="left">
    character </td><td align="left"> char ** </td><td align="left"> [see below]</td>
</tr>
<tr>
 <td align="left">
    raw </td><td align="left"> unsigned char * </td><td align="left"> not allowed</td>
</tr>
<tr>
 <td align="left">
    list </td><td align="left"> SEXP *</td><td align="left"> not allowed</td>
</tr>
<tr>
 <td align="left">
    other </td><td align="left"> SEXP</td><td align="left"> not allowed</td>
</tr>
<tr>
 <td align="left">
  </td>
</tr>

</table>

<p>Numeric vectors in <font face="Courier New,Courier" color="#666666"><b>R</b></font> will be passed as type <code>double *</code> to C
(and as <code>double precision</code> to Fortran) unless the argument has
attribute <code>Csingle</code> set to <code>TRUE</code> (use
<code><a href="double.html">as.single</a></code> or <code><a href="double.html">single</a></code>).  This mechanism is
only intended to be used to facilitate the interfacing of existing C
and Fortran code.
</p>
<p>The C type <code>Rcomplex</code> is defined in &lsquo;<span class="file">Complex.h</span>&rsquo; as a
<code>typedef struct {double r; double i;}</code>.  It may or may not be
equivalent to the C99 <code>double complex</code> type, depending on the
compiler used.
</p>
<p>Logical values are sent as <code>0</code> (<code>FALSE</code>), <code>1</code>
(<code>TRUE</code>) or <code>INT_MIN = -2147483648</code> (<code>NA</code>, but only if
<code>NAOK = TRUE</code>), and the compiled code should return one of these
three values: however non-zero values other than <code>INT_MIN</code> are
mapped to <code>TRUE</code>.
</p>
<p><EM>Note:</EM> The C types corresponding to <code>integer</code> and
<code>logical</code> are <code>int</code>, not <code>long</code> as in S.  This
difference matters on most 64-bit platforms, where <code>int</code> is
32-bit and <code>long</code> is 64-bit (but not on 64-bit Windows).
</p>
<p><EM>Note:</EM> The Fortran type corresponding to <code>logical</code> is
<code>integer</code>, not <code>logical</code>: the difference matters on some
Fortran compilers.
</p>
<p>Missing (<code>NA</code>) string values are passed to <code>.C</code> as the string
&quot;NA&quot;. As the C <code>char</code> type can represent all possible bit patterns
there appears to be no way to distinguish missing strings from the
string <code>"NA"</code>.  If this distinction is important use <code><a href="CallExternal.html">.Call</a></code>.
</p>
<p><code>.Fortran</code> passes the first (only) character string of a character
vector is passed as a C character array to Fortran: that may be usable
as <code>character*255</code> if its true length is passed separately.  Only
up to 255 characters of the string are passed back.  (How well this
works, and even if it works at all, depends on the C and Fortran
compilers and the platform.)
</p>
<p>Lists, functions are other <font face="Courier New,Courier" color="#666666"><b>R</b></font> objects can (for historical reasons) be
passed to <code>.C</code>, but the <code><a href="CallExternal.html">.Call</a></code> interface is much
preferred.  All inputs apart from atomic vectors should be regarded as
read-only, and all apart from vectors (including lists), functions and
environments are now deprecated.
</p>


<h3>Warning</h3>

<p><code>DUP = FALSE</code> <EM>is dangerous</EM> and may be disabled in future
versions of <font face="Courier New,Courier" color="#666666"><b>R</b></font>.  It was deprecated in <font face="Courier New,Courier" color="#666666"><b>R</b></font> 3.1.0.
</p>
<p>People concerned about performance and especially memory usage are
strongly recommended to use the <code><a href="CallExternal.html">.Call</a></code> interface instead
of these interfaces.
</p>
<p>If you pass a local variable to <code>.C</code>/<code>.Fortran</code> with
<code>DUP = FALSE</code>, your compiled code can alter the local variable and
not just the copy in the return list.  Worse, if you pass a local
variable that is a formal parameter of the calling function, you may
be able to change not only the local variable but the variable one
level up.  This will be very hard to trace.
</p>
<p>With <code>DUP = FALSE</code>, character vectors cannot be used, and single
precision values will not be returned.
</p>
<p>It is safe to set <code>DUP = FALSE</code> provided you do not change any of
the variables that might be affected, e.g.,
</p>
<p><code>.C("Cfunction", input = x, output = numeric(10))</code>.
</p>
<p>In this case the <code>output</code> variable did not exist before the call
so is not copied (even with <code>DUP = TRUE</code>).  <EM>If</EM> the
<code>input</code> variable is not changed in the C code of <code>Cfunction</code>
you would be safe.  Unfortunately, there is no automated check that
the C function does not change its argument, and authors have
frequently done so without realizing it.
</p>
<p>However, in recent versions of <font face="Courier New,Courier" color="#666666"><b>R</b></font> most unnecessary copying is avoided:
on the other hand using <code>DUP = FALSE</code> can omit <EM>necessary</EM>
copying.
</p>


<h3>Fortran symbol names</h3>

<p>All Fortran compilers known to be usable to compile <font face="Courier New,Courier" color="#666666"><b>R</b></font> map symbol names
to lower case, and so does <code>.Fortran</code>.
</p>
<p>Symbol names containing underscores are not valid Fortran 77 (although
they are valid in Fortran 9x).  Many Fortran 77 compilers will allow
them but may translate them in a different way to names not containing
underscores.  Such names will often work with <code>.Fortran</code> (since
how they are translated is detected when <font face="Courier New,Courier" color="#666666"><b>R</b></font> is built and the
information used by <code>.Fortran</code>), but portable code should not use
Fortran names containing underscores.
</p>
<p>Use <code>.Fortran</code> with care for compiled Fortran 9x code: it may not
work if the Fortran 9x compiler used differs from the Fortran 77 compiler
used when configuring <font face="Courier New,Courier" color="#666666"><b>R</b></font>, especially if the subroutine name is not
lower-case or includes an underscore.  It is also possible to use
<code>.C</code> and do any necessary symbol-name translation yourself.
</p>


<h3>Copying of arguments</h3>

<p>If <code>DUP = TRUE</code> there are up to two copies made of each argument
in <code>...</code>.
</p>
<p>Prior to <font face="Courier New,Courier" color="#666666"><b>R</b></font> 2.15.1 there were always two for vectors (one before
calling the compiled code and one to collect the results), and this is
still the case for character vectors.  For other atomic vectors, the
argument is not copied before calling the compiled code if it is not
otherwise used in the calling code (such as <code>output</code> in the
example above).  Non-atomic-vector objects are read-only to the C code
and are never copied.
</p>
<p>This behaviour can be changed by setting
<code><a href="options.html">options</a>(CBoundsCheck = TRUE)</code>.  In that case raw,
logical, integer, double and complex vector arguments are copied both
before and after calling the compiled code.  The first copy made is
extended at each end by guard bytes, and on return it is checked that
these are unaltered.  For <code>.C</code>, each element of a character
vector uses guard bytes.
</p>


<h3>Note</h3>

<p>If one of these functions is to be used frequently, do specify
<code>PACKAGE</code> (to confine the search to a single DLL) or pass
<code>.NAME</code> as one of the native symbol objects.  Searching for
symbols can take a long time, especially when many namespaces are loaded.
</p>
<p>You may see <code>PACKAGE = "base"</code> for symbols linked into <font face="Courier New,Courier" color="#666666"><b>R</b></font>.  Do
not use this in your own code: such symbols are not part of the API
and may be changed without warning.
</p>
<p><code>PACKAGE = ""</code> used to be accepted (but was undocumented): it is
now an error.
</p>
<p>The way <a href="list.html">pairlist</a>s were passed by <code>.C</code> prior to <font face="Courier New,Courier" color="#666666"><b>R</b></font> 2.15.0
was not as documented.  This has been corrected, but the
<code><a href="CallExternal.html">.Call</a></code> and <code><a href="CallExternal.html">.External</a></code> interfaces are much
preferred for passing anything other than atomic vectors.
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
<EM>The New S Language</EM>.
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="dynload.html">dyn.load</a></code>, <code><a href="CallExternal.html">.Call</a></code>.
</p>
<p>The &lsquo;Writing R Extensions&rsquo; manual.
</p>

<hr><div align="center">[Package <em>base</em> version 3.1.0 <a href="00Index.html">Index</a>]</div>
</body></html>
